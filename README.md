# KoktajLove

Oto wygenerowana struktura katalogów i podstawowy kod boilerplate dla frontendu aplikacji "KoktajLOVE".

```typescript
// frontend/.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-temporary-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarnclean

# dotenv environment variables file
.env
.env*.local

# Vite build output
dist
dist-ssr

# SvelteKit build output
.svelte-kit

# Next.js build output
.next

# Nuxt.js build output
.nuxt

# Remix build output
.cache/
build/
public/build/

# Docusaurus build output
.docusaurus

# Gatsby build output
.cache/
public

# Parcel build output
.parcel-cache

# Storybook build output
storybook-static

# SvelteKit serverless functions
.vercel_build_output

# Temporary files
.tmp
tmp

# macOS
.DS_Store
```

```markdown
// frontend/README.md
# KoktajLOVE Frontend

Frontend aplikacji webowej "KoktajLOVE" napisany w React z TypeScript, wykorzystujący Vite.

## Główne Technologie

*   **Framework:** React (v18+) z TypeScript
*   **Build Tool:** Vite (z szablonem React-TS + SWC)
*   **Routing:** React Router DOM (v6+)
*   **Zarządzanie stanem:**
    *   Globalny: React Context API (uwierzytelnienie)
    *   Lokalny: Hooki `useState` i `useReducer`
    *   Stan serwera: Axios w serwisach + `useApi` hook
*   **Komunikacja HTTP:** Axios
*   **Stylizacja:** CSS Modules + globalne style CSS
*   **Walidacja formularzy:** React Hook Form
*   **Formatowanie kodu i Linting:** Prettier i ESLint

## Struktura Projektu

Struktura projektu znajduje się w katalogu `frontend/`. Główne katalogi w `src/`:

*   `assets/`: Statyczne zasoby (obrazy, fonty).
*   `components/`: Reużywalne komponenty UI, layoutu i specyficzne dla funkcjonalności.
*   `contexts/`: Konteksty React (np. `AuthContext`).
*   `hooks/`: Customowe hooki React.
*   `pages/`: Komponenty reprezentujące widoki/strony aplikacji.
*   `router/`: Konfiguracja routingu.
*   `services/`: Logika komunikacji z API.
*   `styles/`: Globalne style i zmienne CSS.
*   `types/`: Definicje typów TypeScript.
*   `utils/`: Funkcje pomocnicze.

## Dostępne Skrypty

W katalogu projektu możesz uruchomić:

### `npm run dev`

Uruchamia aplikację w trybie deweloperskim.<br />
Otwórz [http://localhost:5173](http://localhost:5173) (lub inny port wskazany przez Vite) aby zobaczyć ją w przeglądarce.

Strona będzie się automatycznie przeładowywać po dokonaniu zmian.<br />
Zobaczysz również błędy lintowania w konsoli.

### `npm run build`

Buduje aplikację do produkcyjnego folderu `dist/`.<br />
Poprawnie bundluje React w trybie produkcyjnym i optymalizuje build dla najlepszej wydajności.

### `npm run lint`

Uruchamia ESLint do analizy kodu pod kątem błędów i stylu.

### `npm run format`

Uruchamia Prettier do automatycznego formatowania kodu.

### `npm run preview`

Uruchamia lokalny serwer statyczny z produkcyjną wersją aplikacji z folderu `dist/`.

## Zmienne Środowiskowe

Aplikacja używa zmiennych środowiskowych do konfiguracji, np. adresu URL backendu.

*   Skopiuj plik `.env.example` do `.env`.
*   Dostosuj wartości w pliku `.env` do swojej konfiguracji.

Przykład:
`VITE_API_BASE_URL=http://localhost:8000/api/v1`
```

```javascript
// frontend/eslint.config.js
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";
import pluginReactConfig from "eslint-plugin-react/configs/recommended.js";
import pluginReactHooks from "eslint-plugin-react-hooks";
import pluginReactRefresh from "eslint-plugin-react-refresh";
import eslintPluginJsxA11y from "eslint-plugin-jsx-a11y";

export default [
  { files: ["**/*.{js,mjs,cjs,ts,jsx,tsx}"] },
  { languageOptions: { globals: { ...globals.browser, ...globals.es2020 } } },
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
  { 
    ...pluginReactConfig, 
    settings: { react: { version: "detect" } } 
  },
  { 
    plugins: {
      'react-hooks': pluginReactHooks,
      'react-refresh': pluginReactRefresh,
      'jsx-a11y': eslintPluginJsxA11y,
    },
    rules: {
      ...pluginReactHooks.configs.recommended.rules,
      "react-refresh/only-export-components": [
        "warn",
        { allowConstantExport: true },
      ],
      "react/react-in-jsx-scope": "off", // Not needed with new JSX transform
      "react/prop-types": "off", // Using TypeScript for prop types
      "@typescript-eslint/no-unused-vars": ["warn", { "argsIgnorePattern": "^_" }],
      // Example: Add specific jsx-a11y rules if needed
      // "jsx-a11y/anchor-is-valid": "warn", 
    }
  },
  {
    // Ignores for config files
    ignores: ["dist/", "node_modules/", "vite.config.ts", "eslint.config.js", ".prettierrc.json"],
  }
];
```

```html
// frontend/index.html
<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KoktajLOVE</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

```json
// frontend/package.json
{
  "name": "koktajlove-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "format": "prettier --write \"**/*.{ts,tsx,css,md,json}\"",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.3",
    "axios": "^1.6.8",
    "react-hook-form": "^7.51.2"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@types/react-router-dom": "^5.3.3",
    "typescript": "^5.2.2",
    "vite": "^5.2.0",
    "@vitejs/plugin-react-swc": "^3.5.0",
    "eslint": "^8.57.0",
    "prettier": "^3.2.5",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "eslint-plugin-jsx-a11y": "^6.8.0",
    "globals": "^15.0.0"
  }
}
```

```
// frontend/public/vite.svg
<svg width="128" height="128" viewBox="0 0 128 128" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><linearGradient id="a" x1="8.96%" x2="90.68%" y1="14.01%" y2="85.27%"><stop offset="0%" stop-color="#7296EB"/><stop offset="100%" stop-color="#3C69D1"/></linearGradient><linearGradient id="b" x1="8.96%" x2="90.68%" y1="14.01%" y2="85.27%"><stop offset="0%" stop-color="#FFDA90"/><stop offset="100%" stop-color="#FFB02F"/></linearGradient><linearGradient id="c" x1="50%" x2="50%" y1="0%" y2="100%"><stop offset="0%" stop-color="#A4A9B3" stop-opacity="0"/><stop offset="100%" stop-color="#A4A9B3"/></linearGradient><filter id="d" width="200%" height="200%" x="-50%" y="-50%"><feGaussianBlur in="SourceGraphic" stdDeviation="2.9"/></filter></defs><g fill="none" fill-rule="evenodd"><path fill="url(#a)" d="M111.904 79.773l-47.95 27.684a16.565 16.565 0 01-16.573 0L0 80.036 16.427 0l47.95 27.684a16.565 16.565 0 0116.573 0L128 27.421z"/><g opacity=".24" transform="translate(16.427)"><path fill="#A4A9B3" filter="url(#d)" d="M95.477 79.773l-47.95 27.684a16.565 16.565 0 01-16.573 0L-16.427 80.036 0 0l47.95 27.684a16.565 16.565 0 0116.573 0L111.904 27.421z"/></g><g transform="rotate(180 55.952 53.728)"><path fill="url(#b)" d="M95.477 79.773l-47.95 27.684a16.565 16.565 0 01-16.573 0L-16.427 80.036 0 0l47.95 27.684a16.565 16.565 0 0116.573 0L111.904 27.421z"/></g><path fill="url(#c)" style="mix-blend-mode:soft-light" d="M111.904 79.773l-47.95 27.684a16.565 16.565 0 01-16.573 0L0 80.036 16.427 0l47.95 27.684a16.565 16.565 0 0116.573 0L128 27.421z"/><path fill="#FFF" style="mix-blend-mode:overlay" d="M111.904 79.773l-47.95 27.684a16.565 16.565 0 01-16.573 0L0 80.036 16.427 0l47.95 27.684a16.565 16.565 0 0116.573 0L128 27.421z"/></g></svg>
```

```
// frontend/src/.env
VITE_API_BASE_URL=http://localhost:8000/api/v1
```

```
// frontend/src/.env.example
VITE_API_BASE_URL=http://localhost:8000/api/v1
```

```css
// frontend/src/App.css
/* Global styles for App component if needed, or move to styles/global.css */
/* Example: */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f4f4f9; /* Light gray background */
  color: #333; /* Default text color */
}

#root {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

main {
  flex-grow: 1;
  padding: 1rem; /* Add some padding to main content area */
  max-width: 1200px; /* Max width for content */
  margin: 0 auto; /* Center content */
  width: 100%;
  box-sizing: border-box;
}

/* Basic link styling */
a {
  color: #007bff; /* Example primary color */
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}
```

```tsx
// frontend/src/App.tsx
import React from 'react';
import { AuthProvider } from './contexts/AuthContext';
import AppRoutes from './router/AppRoutes';
import './App.css'; // Or styles/global.css if preferred for body/root styles
import './styles/global.css'; // More specific global styles

function App() {
  return (
    <React.StrictMode>
      <AuthProvider>
        <AppRoutes />
      </AuthProvider>
    </React.StrictMode>
  );
}

export default App;
```

```svg
// frontend/src/assets/react.svg
<svg xmlns="http://www.w3.org/2000/svg" viewBox="-11.5 -10.23174 23 20.46348">
  <title>React Logo</title>
  <circle cx="0" cy="0" r="2.05" fill="#61dafb"/>
  <g stroke="#61dafb" stroke-width="1" fill="none">
    <ellipse rx="11" ry="4.2"/>
    <ellipse rx="11" ry="4.2" transform="rotate(60)"/>
    <ellipse rx="11" ry="4.2" transform="rotate(120)"/>
  </g>
</svg>
```

```css
// frontend/src/components/features/auth/LoginForm.module.css
.formContainer {
  max-width: 400px;
  margin: 2rem auto;
  padding: 2rem;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.formTitle {
  text-align: center;
  margin-bottom: 1.5rem;
  color: #333;
}

.formGroup {
  margin-bottom: 1rem;
}

.formGroup label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
  color: #555;
}

.errorMessage {
  color: red;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

.submitButton {
  width: 100%;
  padding: 0.75rem;
  font-size: 1rem;
}

.serverError {
  color: red;
  text-align: center;
  margin-bottom: 1rem;
}
```

```tsx
// frontend/src/components/features/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useForm, SubmitHandler } from 'react-hook-form';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';
import * as authService from '@/services/authService';
import { LoginCredentials } from '@/types/authTypes';
import Button from '@/components/ui/Button/Button';
import Input from '@/components/ui/Input/Input';
import styles from './LoginForm.module.css';

const LoginForm: React.FC = () => {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<LoginCredentials>();
  const auth = useAuth();
  const navigate = useNavigate();
  const [serverError, setServerError] = useState<string | null>(null);

  const onSubmit: SubmitHandler<LoginCredentials> = async (data) => {
    setServerError(null);
    try {
      const { token, user } = await authService.loginUser(data);
      auth.login(token, user);
      navigate('/profile'); // Or to the last visited page
    } catch (error: any) {
      const errorMessage = error.response?.data?.detail || 'Login failed. Please check your credentials.';
      setServerError(errorMessage);
      console.error('Login error:', error);
    }
  };

  return (
    <div className={styles.formContainer}>
      <h2 className={styles.formTitle}>Login</h2>
      {serverError && <p className={styles.serverError}>{serverError}</p>}
      <form onSubmit={handleSubmit(onSubmit)}>
        <div className={styles.formGroup}>
          <label htmlFor="username">Username or Email</label>
          <Input
            id="username"
            type="text"
            {...register('username', { required: 'Username or email is required' })}
            aria-invalid={errors.username ? "true" : "false"}
          />
          {errors.username && <p className={styles.errorMessage} role="alert">{errors.username.message}</p>}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="password">Password</label>
          <Input
            id="password"
            type="password"
            {...register('password', { required: 'Password is required' })}
            aria-invalid={errors.password ? "true" : "false"}
          />
          {errors.password && <p className={styles.errorMessage} role="alert">{errors.password.message}</p>}
        </div>

        <Button type="submit" disabled={isSubmitting} className={styles.submitButton}>
          {isSubmitting ? 'Logging in...' : 'Login'}
        </Button>
      </form>
    </div>
  );
};

export default LoginForm;
```

```css
// frontend/src/components/features/auth/RegisterForm.module.css
.formContainer {
  max-width: 450px;
  margin: 2rem auto;
  padding: 2rem;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.formTitle {
  text-align: center;
  margin-bottom: 1.5rem;
  color: #333;
}

.formGroup {
  margin-bottom: 1rem;
}

.formGroup label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
  color: #555;
}

.errorMessage {
  color: red;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

.submitButton {
  width: 100%;
  padding: 0.75rem;
  font-size: 1rem;
}

.serverError {
  color: red;
  text-align: center;
  margin-bottom: 1rem;
}
```

```tsx
// frontend/src/components/features/auth/RegisterForm.tsx
import React, { useState } from 'react';
import { useForm, SubmitHandler } from 'react-hook-form';
import { useNavigate } from 'react-router-dom';
import * as authService from '@/services/authService';
import { RegisterData } from '@/types/authTypes';
import Button from '@/components/ui/Button/Button';
import Input from '@/components/ui/Input/Input';
import styles from './RegisterForm.module.css';

const RegisterForm: React.FC = () => {
  const { register, handleSubmit, formState: { errors, isSubmitting }, watch } = useForm<RegisterData>();
  const navigate = useNavigate();
  const [serverError, setServerError] = useState<string | null>(null);
  const password = watch('password');

  const onSubmit: SubmitHandler<RegisterData> = async (data) => {
    setServerError(null);
    // Omit confirmPassword before sending to backend if it exists in the form data
    const { confirmPassword, ...registrationData } = data as RegisterData & { confirmPassword?: string };
    
    try {
      await authService.registerUser(registrationData);
      // Optionally: log the user in directly or show a success message
      // For now, navigate to login page
      navigate('/login', { state: { message: 'Registration successful! Please log in.' } });
    } catch (error: any) {
      const errorMessage = error.response?.data?.detail || 'Registration failed. Please try again.';
      setServerError(errorMessage);
      console.error('Registration error:', error);
    }
  };

  return (
    <div className={styles.formContainer}>
      <h2 className={styles.formTitle}>Register</h2>
      {serverError && <p className={styles.serverError}>{serverError}</p>}
      <form onSubmit={handleSubmit(onSubmit)}>
        <div className={styles.formGroup}>
          <label htmlFor="username">Username</label>
          <Input
            id="username"
            type="text"
            {...register('username', { 
              required: 'Username is required',
              minLength: { value: 3, message: 'Username must be at least 3 characters' } 
            })}
            aria-invalid={errors.username ? "true" : "false"}
          />
          {errors.username && <p className={styles.errorMessage} role="alert">{errors.username.message}</p>}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="email">Email</label>
          <Input
            id="email"
            type="email"
            {...register('email', { 
              required: 'Email is required',
              pattern: {
                value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
                message: 'Invalid email address'
              }
            })}
            aria-invalid={errors.email ? "true" : "false"}
          />
          {errors.email && <p className={styles.errorMessage} role="alert">{errors.email.message}</p>}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="password">Password</label>
          <Input
            id="password"
            type="password"
            {...register('password', { 
              required: 'Password is required',
              minLength: { value: 6, message: 'Password must be at least 6 characters' }
            })}
            aria-invalid={errors.password ? "true" : "false"}
          />
          {errors.password && <p className={styles.errorMessage} role="alert">{errors.password.message}</p>}
        </div>

        <div className={styles.formGroup}>
          <label htmlFor="confirmPassword">Confirm Password</label>
          <Input
            id="confirmPassword"
            type="password"
            {...register('confirmPassword' as any, { // Using 'any' here because confirmPassword is not in RegisterData
              required: 'Please confirm your password',
              validate: value => value === password || 'Passwords do not match'
            })}
            aria-invalid={errors.confirmPassword ? "true" : "false"}
          />
          {errors.confirmPassword && <p className={styles.errorMessage} role="alert">{errors.confirmPassword.message}</p>}
        </div>

        <Button type="submit" disabled={isSubmitting} className={styles.submitButton}>
          {isSubmitting ? 'Registering...' : 'Register'}
        </Button>
      </form>
    </div>
  );
};

export default RegisterForm;
```

```css
// frontend/src/components/features/cocktails/CocktailCard.module.css
.card {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 1rem;
  margin: 0.5rem;
  background-color: #fff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  transition: transform 0.2s ease-in-out;
}

.card:hover {
  transform: translateY(-5px);
}

.image {
  width: 100%;
  max-height: 200px;
  object-fit: cover;
  border-radius: 4px;
  margin-bottom: 0.75rem;
}

.name {
  font-size: 1.25rem;
  font-weight: bold;
  margin-bottom: 0.5rem;
  color: #333;
}

.description {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 0.75rem;
  flex-grow: 1; /* Makes description take available space */
}

.tagsContainer {
  margin-bottom: 0.5rem;
}

.tag {
  display: inline-block;
  background-color: #e0e0e0;
  color: #555;
  padding: 0.25rem 0.5rem;
  border-radius: 12px;
  font-size: 0.75rem;
  margin-right: 0.25rem;
  margin-bottom: 0.25rem;
}

.rating {
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
}

.detailsLink {
  align-self: flex-start; /* Aligns button to the left */
  margin-top: auto; /* Pushes button to the bottom */
}
```

```tsx
// frontend/src/components/features/cocktails/CocktailCard.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import { CocktailWithDetails, Tag } from '@/types/cocktailTypes';
import RatingStars from './RatingStars'; // Assuming you have this component
import Button from '@/components/ui/Button/Button';
import styles from './CocktailCard.module.css';

interface CocktailCardProps {
  cocktail: CocktailWithDetails; // Or a simpler CocktailListType
}

const CocktailCard: React.FC<CocktailCardProps> = ({ cocktail }) => {
  const placeholderImage = 'https://via.placeholder.com/300x200.png?text=No+Image';

  return (
    <div className={styles.card}>
      <img 
        src={cocktail.image_url || placeholderImage} 
        alt={cocktail.name} 
        className={styles.image} 
        onError={(e) => (e.currentTarget.src = placeholderImage)}
      />
      <h3 className={styles.name}>{cocktail.name}</h3>
      <p className={styles.description}>
        {cocktail.description.length > 100 
          ? `${cocktail.description.substring(0, 100)}...` 
          : cocktail.description}
      </p>
      
      {cocktail.average_rating !== undefined && cocktail.average_rating !== null && (
        <div className={styles.rating}>
          <RatingStars rating={cocktail.average_rating} readOnly />
          ({cocktail.average_rating.toFixed(1)})
        </div>
      )}

      {cocktail.tags && cocktail.tags.length > 0 && (
        <div className={styles.tagsContainer}>
          {cocktail.tags.slice(0, 3).map((tag: Tag) => ( // Show max 3 tags
            <span key={tag.id} className={styles.tag}>{tag.name}</span>
          ))}
        </div>
      )}
      
      <Button 
        as={Link} 
        to={`/cocktail/${cocktail.id}`} 
        variant="secondary"
        className={styles.detailsLink}
      >
        View Details
      </Button>
    </div>
  );
};

export default CocktailCard;
```

```css
// frontend/src/components/features/cocktails/CocktailForm.module.css
.form {
  max-width: 700px;
  margin: 2rem auto;
  padding: 2rem;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
}

.formTitle {
  text-align: center;
  margin-bottom: 1.5rem;
}

.formGroup {
  margin-bottom: 1rem;
}

.formGroup label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: bold;
}

.formGroup textarea {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  min-height: 100px;
  box-sizing: border-box;
}

.errorMessage {
  color: red;
  font-size: 0.875rem;
  margin-top: 0.25rem;
}

.ingredientsSection, .tagsSection {
  margin-top: 1.5rem;
  padding-top: 1rem;
  border-top: 1px dashed #eee;
}

.ingredientItem, .tagItem {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  margin-bottom: 0.5rem;
}

.ingredientItem select, .ingredientItem input {
  flex-grow: 1;
}

.checkboxLabel {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-weight: normal;
}

.checkboxLabel input[type="checkbox"] {
  margin-right: 0.5rem;
}

.submitButton {
  margin-top: 1.5rem;
  width: 100%;
}
```

```tsx
// frontend/src/components/features/cocktails/CocktailForm.tsx
import React, { useEffect, useState } from 'react';
import { useForm, SubmitHandler, useFieldArray, Controller } from 'react-hook-form';
import { useNavigate } from 'react-router-dom';
import { CocktailCreate, CocktailUpdate, CocktailWithDetails, Ingredient, Tag, UnitEnum } from '@/types';
import * as cocktailService from '@/services/cocktailService';
import * as ingredientService from '@/services/ingredientService';
import * as tagService from '@/services/tagService';
import Button from '@/components/ui/Button/Button';
import Input from '@/components/ui/Input/Input';
import styles from './CocktailForm.module.css';

// Form data type, includes all fields including those for react-hook-form
type CocktailFormData = Omit<CocktailCreate, 'ingredients' | 'tag_ids'> & {
  ingredients: { ingredient_id: string; quantity: string; unit: UnitEnum }[];
  tag_ids: string[]; // RHF works better with string array for multi-select or checkboxes
};

interface CocktailFormProps {
  cocktail?: CocktailWithDetails; // For editing
  onSubmitSuccess?: (cocktail: CocktailWithDetails) => void;
}

const CocktailForm: React.FC<CocktailFormProps> = ({ cocktail, onSubmitSuccess }) => {
  const navigate = useNavigate();
  const { 
    register, 
    handleSubmit, 
    control, 
    formState: { errors, isSubmitting },
    setValue,
    reset 
  } = useForm<CocktailFormData>({
    defaultValues: cocktail 
      ? {
          name: cocktail.name,
          description: cocktail.description,
          instructions: cocktail.instructions,
          image_url: cocktail.image_url || '',
          is_public: cocktail.is_public,
          ingredients: cocktail.ingredients.map(ci => ({
            ingredient_id: String(ci.ingredient.id),
            quantity: String(ci.quantity),
            unit: ci.unit,
          })),
          tag_ids: cocktail.tags.map(t => String(t.id)),
        } 
      : {
          name: '',
          description: '',
          instructions: '',
          image_url: '',
          is_public: true,
          ingredients: [{ ingredient_id: '', quantity: '', unit: UnitEnum.ml }],
          tag_ids: [],
        },
  });

  const { fields, append, remove } = useFieldArray({
    control,
    name: 'ingredients',
  });

  const [availableIngredients, setAvailableIngredients] = useState<Ingredient[]>([]);
  const [availableTags, setAvailableTags] = useState<Tag[]>([]);
  const [formError, setFormError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [ingredientsRes, tagsRes] = await Promise.all([
          ingredientService.getIngredients(),
          tagService.getTags(),
        ]);
        setAvailableIngredients(ingredientsRes);
        setAvailableTags(tagsRes);
      } catch (error) {
        console.error('Failed to fetch ingredients or tags', error);
        setFormError('Could not load necessary data for the form.');
      }
    };
    fetchData();
  }, []);

  useEffect(() => { // Reset form if cocktail prop changes (e.g. for editing)
    if (cocktail) {
        reset({
            name: cocktail.name,
            description: cocktail.description,
            instructions: cocktail.instructions,
            image_url: cocktail.image_url || '',
            is_public: cocktail.is_public,
            ingredients: cocktail.ingredients.map(ci => ({
              ingredient_id: String(ci.ingredient.id),
              quantity: String(ci.quantity),
              unit: ci.unit,
            })),
            tag_ids: cocktail.tags.map(t => String(t.id)),
          });
    } else {
        reset({
            name: '',
            description: '',
            instructions: '',
            image_url: '',
            is_public: true,
            ingredients: [{ ingredient_id: '', quantity: '', unit: UnitEnum.ml }],
            tag_ids: [],
          });
    }
  }, [cocktail, reset]);


  const onSubmit: SubmitHandler<CocktailFormData> = async (data) => {
    setFormError(null);
    const payload: CocktailCreate | CocktailUpdate = {
      ...data,
      ingredients: data.ingredients.map(ing => ({
        ingredient_id: parseInt(ing.ingredient_id, 10),
        quantity: parseFloat(ing.quantity),
        unit: ing.unit,
      })).filter(ing => !isNaN(ing.ingredient_id) && !isNaN(ing.quantity)), // Filter out invalid entries
      tag_ids: data.tag_ids.map(id => parseInt(id, 10)),
      is_public: data.is_public === undefined ? true : data.is_public, // Default to true if undefined
    };

    try {
      let savedCocktail;
      if (cocktail?.id) {
        savedCocktail = await cocktailService.updateCocktail(cocktail.id, payload as CocktailUpdate);
      } else {
        savedCocktail = await cocktailService.createCocktail(payload as CocktailCreate);
      }
      
      if (onSubmitSuccess) {
        onSubmitSuccess(savedCocktail);
      } else {
        navigate(`/cocktail/${savedCocktail.id}`);
      }
    } catch (error: any) {
      console.error('Failed to save cocktail', error);
      setFormError(error.response?.data?.detail || 'An error occurred while saving the cocktail.');
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className={styles.form}>
      <h2 className={styles.formTitle}>{cocktail ? 'Edit Cocktail' : 'Add New Cocktail'}</h2>
      {formError && <p className={styles.errorMessage}>{formError}</p>}

      <div className={styles.formGroup}>
        <label htmlFor="name">Name</label>
        <Input id="name" {...register('name', { required: 'Name is required' })} />
        {errors.name && <p className={styles.errorMessage}>{errors.name.message}</p>}
      </div>

      <div className={styles.formGroup}>
        <label htmlFor="description">Description</label>
        <textarea id="description" {...register('description', { required: 'Description is required' })} />
        {errors.description && <p className={styles.errorMessage}>{errors.description.message}</p>}
      </div>

      <div className={styles.formGroup}>
        <label htmlFor="instructions">Instructions</label>
        <textarea id="instructions" {...register('instructions', { required: 'Instructions are required' })} />
        {errors.instructions && <p className={styles.errorMessage}>{errors.instructions.message}</p>}
      </div>

      <div className={styles.formGroup}>
        <label htmlFor="image_url">Image URL (optional)</label>
        <Input id="image_url" type="url" {...register('image_url')} />
        {errors.image_url && <p className={styles.errorMessage}>{errors.image_url.message}</p>}
      </div>
      
      <div className={styles.formGroup}>
        <label className={styles.checkboxLabel}>
          <input type="checkbox" {...register('is_public')} defaultChecked={cocktail?.is_public ?? true} />
          Publicly Visible
        </label>
      </div>

      <section className={styles.ingredientsSection}>
        <h3>Ingredients</h3>
        {fields.map((field, index) => (
          <div key={field.id} className={styles.ingredientItem}>
            <Controller
              name={`ingredients.${index}.ingredient_id`}
              control={control}
              rules={{ required: 'Ingredient is required' }}
              render={({ field }) => (
                <select {...field}>
                  <option value="">Select Ingredient</option>
                  {availableIngredients.map(ing => (
                    <option key={ing.id} value={ing.id}>{ing.name}</option>
                  ))}
                </select>
              )}
            />
            <Input
              type="number"
              step="0.1"
              placeholder="Qty"
              {...register(`ingredients.${index}.quantity`, { 
                required: 'Quantity is required', 
                valueAsNumber: true,
                min: { value: 0.1, message: "Quantity must be positive" }
              })}
            />
            <Controller
              name={`ingredients.${index}.unit`}
              control={control}
              rules={{ required: 'Unit is required' }}
              render={({ field }) => (
                <select {...field}>
                  {Object.values(UnitEnum).map(unit => (
                    <option key={unit} value={unit}>{unit}</option>
                  ))}
                </select>
              )}
            />
            <Button type="button" onClick={() => remove(index)} variant="danger" size="small">Remove</Button>
          </div>
        ))}
         {errors.ingredients && errors.ingredients.map((error, index) => (
            <div key={index} className={styles.errorMessage}>
              {error?.ingredient_id && <p>{error.ingredient_id.message}</p>}
              {error?.quantity && <p>{error.quantity.message}</p>}
              {error?.unit && <p>{error.unit.message}</p>}
            </div>
          ))}
        <Button type="button" onClick={() => append({ ingredient_id: '', quantity: '', unit: UnitEnum.ml })} variant="secondary">
          Add Ingredient
        </Button>
      </section>

      <section className={styles.tagsSection}>
        <h3>Tags (optional)</h3>
        <div className={styles.formGroup}>
            {availableTags.map(tag => (
                <label key={tag.id} className={styles.checkboxLabel}>
                    <input
                        type="checkbox"
                        value={tag.id}
                        {...register('tag_ids')}
                    />
                    {tag.name}
                </label>
            ))}
        </div>
        {errors.tag_ids && <p className={styles.errorMessage}>{errors.tag_ids.message}</p>}
      </section>

      <Button type="submit" disabled={isSubmitting} className={styles.submitButton}>
        {isSubmitting ? (cocktail ? 'Saving...' : 'Adding...') : (cocktail ? 'Save Changes' : 'Add Cocktail')}
      </Button>
    </form>
  );
};

export default CocktailForm;
```

```css
// frontend/src/components/features/cocktails/CocktailList.module.css
.listContainer {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 1rem;
  padding: 1rem;
}

.loading, .error, .noCocktails {
  grid-column: 1 / -1; /* Span all columns */
  text-align: center;
  padding: 2rem;
  font-size: 1.2rem;
  color: #555;
}

.error {
  color: red;
}
```

```tsx
// frontend/src/components/features/cocktails/CocktailList.tsx
import React from 'react';
import { CocktailWithDetails } from '@/types/cocktailTypes';
import CocktailCard from './CocktailCard';
import Spinner from '@/components/ui/Spinner/Spinner';
import styles from './CocktailList.module.css';

interface CocktailListProps {
  cocktails: CocktailWithDetails[];
  isLoading: boolean;
  error: Error | null;
}

const CocktailList: React.FC<CocktailListProps> = ({ cocktails, isLoading, error }) => {
  if (isLoading) {
    return (
      <div className={styles.loading}>
        <Spinner />
        <p>Loading cocktails...</p>
      </div>
    );
  }

  if (error) {
    return <div className={styles.error}>Error loading cocktails: {error.message}</div>;
  }

  if (!cocktails || cocktails.length === 0) {
    return <div className={styles.noCocktails}>No cocktails found.</div>;
  }

  return (
    <div className={styles.listContainer}>
      {cocktails.map((cocktail) => (
        <CocktailCard key={cocktail.id} cocktail={cocktail} />
      ))}
    </div>
  );
};

export default CocktailList;
```

```css
// frontend/src/components/features/cocktails/RatingStars.module.css
.starsContainer {
  display: inline-flex; /* Align stars in a row */
  align-items: center;
}

.star {
  color: #ccc; /* Default star color (empty) */
  font-size: 1.2em; /* Adjust size as needed */
  cursor: pointer;
  transition: color 0.2s;
}

.star.filled {
  color: #fadb14; /* Filled star color (e.g., gold) */
}

.star.readOnly {
  cursor: default;
}

.star:not(.readOnly):hover,
.star:not(.readOnly):hover ~ .star {
  /* color: #fadb14; /* Highlight on hover, less useful if using filled state */
}
```

```tsx
// frontend/src/components/features/cocktails/RatingStars.tsx
import React, { useState } from 'react';
import styles from './RatingStars.module.css';

interface RatingStarsProps {
  rating: number; // Current rating (0-5)
  maxRating?: number;
  onRatingChange?: (newRating: number) => void;
  readOnly?: boolean;
  size?: 'small' | 'medium' | 'large'; // Optional size prop
}

const RatingStars: React.FC<RatingStarsProps> = ({
  rating,
  maxRating = 5,
  onRatingChange,
  readOnly = false,
  size = 'medium',
}) => {
  const [hoverRating, setHoverRating] = useState(0);

  const handleMouseOver = (index: number) => {
    if (!readOnly) {
      setHoverRating(index);
    }
  };

  const handleMouseLeave = () => {
    if (!readOnly) {
      setHoverRating(0);
    }
  };

  const handleClick = (index: number) => {
    if (!readOnly && onRatingChange) {
      onRatingChange(index);
    }
  };

  const getStarSizeStyle = () => {
    switch (size) {
      case 'small': return { fontSize: '1em' };
      case 'large': return { fontSize: '1.5em' };
      case 'medium':
      default: return { fontSize: '1.2em' };
    }
  };

  return (
    <div className={styles.starsContainer} style={getStarSizeStyle()}>
      {[...Array(maxRating)].map((_, i) => {
        const starValue = i + 1;
        const isFilled = starValue <= (hoverRating || rating);
        
        return (
          <span
            key={starValue}
            className={`${styles.star} ${isFilled ? styles.filled : ''} ${readOnly ? styles.readOnly : ''}`}
            onMouseOver={() => handleMouseOver(starValue)}
            onMouseLeave={handleMouseLeave}
            onClick={() => handleClick(starValue)}
            role={readOnly ? undefined : "button"}
            aria-label={readOnly ? `${starValue} star` : `Rate ${starValue} star`}
            tabIndex={readOnly ? -1 : 0}
            onKeyDown={(e) => {
              if (!readOnly && (e.key === 'Enter' || e.key === ' ')) {
                handleClick(starValue);
              }
            }}
          >
            ★
          </span>
        );
      })}
    </div>
  );
};

export default RatingStars;
```

```css
// frontend/src/components/features/profile/ProfileDetails.module.css
.profileContainer {
  padding: 2rem;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  max-width: 600px;
  margin: 2rem auto;
}

.profileHeader {
  display: flex;
  align-items: center;
  margin-bottom: 1.5rem;
}

.profilePicture {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  object-fit: cover;
  margin-right: 1.5rem;
  border: 3px solid #eee;
}

.username {
  font-size: 2rem;
  font-weight: bold;
  color: #333;
}

.detailsGrid {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 0.75rem 1.5rem;
}

.detailsGrid dt {
  font-weight: bold;
  color: #555;
}

.detailsGrid dd {
  margin-left: 0;
  color: #333;
}

.loading, .error {
  text-align: center;
  padding: 2rem;
  font-size: 1.2rem;
  color: #555;
}

.error {
  color: red;
}
```

```tsx
// frontend/src/components/features/profile/ProfileDetails.tsx
import React from 'react';
import { User } from '@/types/authTypes';
import styles from './ProfileDetails.module.css';
import Spinner from '@/components/ui/Spinner/Spinner';

interface ProfileDetailsProps {
  user: User | null;
  isLoading: boolean;
  error?: string | null;
}

const ProfileDetails: React.FC<ProfileDetailsProps> = ({ user, isLoading, error }) => {
  if (isLoading) {
    return <div className={styles.loading}><Spinner /> <p>Loading profile...</p></div>;
  }

  if (error) {
    return <div className={styles.error}>Error: {error}</div>;
  }

  if (!user) {
    return <div className={styles.loading}>No user data available.</div>;
  }

  const defaultProfilePic = 'https://via.placeholder.com/100?text=User';

  return (
    <div className={styles.profileContainer}>
      <div className={styles.profileHeader}>
        <img 
          src={user.profile_picture_url || defaultProfilePic} 
          alt={`${user.username}'s profile`} 
          className={styles.profilePicture}
          onError={(e) => (e.currentTarget.src = defaultProfilePic)}
        />
        <h2 className={styles.username}>{user.username}</h2>
      </div>
      <dl className={styles.detailsGrid}>
        <dt>Email:</dt>
        <dd>{user.email}</dd>
        <dt>User ID:</dt>
        <dd>{user.id}</dd>
        <dt>Active:</dt>
        <dd>{user.is_active ? 'Yes' : 'No'}</dd>
        {user.is_superuser && (
          <>
            <dt>Role:</dt>
            <dd>Administrator</dd>
          </>
        )}
        {/* Add more details as needed, e.g., join date if available */}
      </dl>
      {/* Future: Add link/button to edit profile */}
    </div>
  );
};

export default ProfileDetails;
```

```css
// frontend/src/components/features/profile/UserCocktailList.module.css
.container {
  margin-top: 2rem;
}

.title {
  font-size: 1.5rem;
  margin-bottom: 1rem;
  color: #333;
  border-bottom: 2px solid #eee;
  padding-bottom: 0.5rem;
}

.list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1rem;
}

.loading, .error, .noCocktails {
  text-align: center;
  padding: 2rem;
  font-size: 1.1rem;
  color: #777;
}

.error {
  color: red;
}
```

```tsx
// frontend/src/components/features/profile/UserCocktailList.tsx
import React, { useEffect, useState } from 'react';
import { CocktailWithDetails } from '@/types/cocktailTypes';
import * as cocktailService from '@/services/cocktailService'; // Assuming a method to get user's cocktails
import * as userService from '@/services/userService'; // Or directly from userService
import CocktailCard from '@/components/features/cocktails/CocktailCard';
import Spinner from '@/components/ui/Spinner/Spinner';
import styles from './UserCocktailList.module.css';

interface UserCocktailListProps {
  userId: number | string; // Or User object if you prefer
}

const UserCocktailList: React.FC<UserCocktailListProps> = ({ userId }) => {
  const [cocktails, setCocktails] = useState<CocktailWithDetails[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUserCocktails = async () => {
      setIsLoading(true);
      setError(null);
      try {
        // Assuming a service function like this exists.
        // It might need adjustments based on your actual API endpoint for user's cocktails.
        // e.g., userService.getUserCocktails(userId) or cocktailService.getCocktails({ owner_id: userId })
        const userCocktails = await userService.getUserCocktails(userId); 
        setCocktails(userCocktails);
      } catch (err: any) {
        console.error('Failed to fetch user cocktails:', err);
        setError(err.message || 'Could not load your cocktails.');
      } finally {
        setIsLoading(false);
      }
    };

    if (userId) {
      fetchUserCocktails();
    }
  }, [userId]);

  if (isLoading) {
    return <div className={styles.loading}><Spinner /><p>Loading your cocktails...</p></div>;
  }

  if (error) {
    return <div className={styles.error}>Error: {error}</div>;
  }

  return (
    <div className={styles.container}>
      <h3 className={styles.title}>My Cocktails</h3>
      {cocktails.length === 0 ? (
        <p className={styles.noCocktails}>You haven't added any cocktails yet.</p>
      ) : (
        <div className={styles.list}>
          {cocktails.map(cocktail => (
            <CocktailCard key={cocktail.id} cocktail={cocktail} />
          ))}
        </div>
      )}
    </div>
  );
};

export default UserCocktailList;
```

```css
// frontend/src/components/layout/Footer/Footer.module.css
.footer {
  background-color: #333;
  color: #fff;
  padding: 1rem 0;
  text-align: center;
  margin-top: auto; /* Pushes footer to the bottom if content is short */
  font-size: 0.9rem;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}
```

```tsx
// frontend/src/components/layout/Footer/Footer.tsx
import React from 'react';
import styles from './Footer.module.css';

const Footer: React.FC = () => {
  const currentYear = new Date().getFullYear();

  return (
    <footer className={styles.footer}>
      <div className={styles.container}>
        <p>&copy; {currentYear} KoktajLOVE. All rights reserved.</p>
        {/* You can add more links or information here */}
      </div>
    </footer>
  );
};

export default Footer;
```

```css
// frontend/src/components/layout/MainLayout/MainLayout.module.css
.layout {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.mainContent {
  flex-grow: 1;
  padding-top: 60px; /* Adjust if Navbar height changes, or use CSS Grid/Flex for better layout */
  /* Alternatively, ensure Navbar is position: fixed or sticky and main has appropriate padding/margin */
  width: 100%;
}
```

```tsx
// frontend/src/components/layout/MainLayout/MainLayout.tsx
import React from 'react';
import { Outlet } from 'react-router-dom';
import Navbar from '../Navbar/Navbar';
import Footer from '../Footer/Footer';
import styles from './MainLayout.module.css';

const MainLayout: React.FC = () => {
  return (
    <div className={styles.layout}>
      <Navbar />
      <main className={styles.mainContent}>
        <Outlet /> {/* Nested routes will render here */}
      </main>
      <Footer />
    </div>
  );
};

export default MainLayout;
```

```css
// frontend/src/components/layout/Navbar/Navbar.module.css
.navbar {
  background-color: #007bff; /* Example primary color */
  padding: 0.75rem 1rem;
  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: fixed; /* Or sticky */
  top: 0;
  left: 0;
  width: 100%;
  z-index: 1000;
  box-sizing: border-box;
}

.logoLink {
  font-size: 1.5rem;
  font-weight: bold;
  color: white;
  text-decoration: none;
}

.navLinks {
  display: flex;
  gap: 1rem; /* Space between links */
}

.navLinks a, .navLinks button {
  color: white;
  text-decoration: none;
  padding: 0.5rem 0.75rem;
  border-radius: 4px;
  transition: background-color 0.2s ease-in-out;
  background: none;
  border: none;
  cursor: pointer;
  font-size: 1rem;
}

.navLinks a:hover, .navLinks button:hover {
  background-color: rgba(255, 255, 255, 0.2);
}

.navLinks .activeLink {
  font-weight: bold;
  background-color: rgba(255, 255, 255, 0.15);
}

.logoutButton {
  /* Specific styles for logout button if needed */
}
```

```tsx
// frontend/src/components/layout/Navbar/Navbar.tsx
import React from 'react';
import { Link, NavLink, useNavigate } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';
import styles from './Navbar.module.css';

const Navbar: React.FC = () => {
  const { user, logout, isLoading } = useAuth();
  const navigate = useNavigate();

  const handleLogout = () => {
    logout();
    navigate('/login');
  };

  const getNavLinkClass = ({ isActive }: { isActive: boolean }) =>
    isActive ? `${styles.navLink} ${styles.activeLink}` : styles.navLink;


  return (
    <nav className={styles.navbar}>
      <Link to="/" className={styles.logoLink}>
        KoktajLOVE
      </Link>
      <div className={styles.navLinks}>
        <NavLink to="/" className={getNavLinkClass} end>
          Home
        </NavLink>
        <NavLink to="/cocktails" className={getNavLinkClass}> {/* Assuming a /cocktails route for listing */}
          Cocktails
        </NavLink>
        
        {!isLoading && user && (
          <>
            <NavLink to="/add-cocktail" className={getNavLinkClass}>
              Add Cocktail
            </NavLink>
            <NavLink to="/my-favorites" className={getNavLinkClass}>
              My Favorites
            </NavLink>
            <NavLink to="/profile" className={getNavLinkClass}>
              My Profile
            </NavLink>
            <button onClick={handleLogout} className={`${styles.navLink} ${styles.logoutButton}`}>
              Logout
            </button>
          </>
        )}
        {!isLoading && !user && (
          <>
            <NavLink to="/login" className={getNavLinkClass}>
              Login
            </NavLink>
            <NavLink to="/register" className={getNavLinkClass}>
              Register
            </NavLink>
          </>
        )}
      </div>
    </nav>
  );
};

export default Navbar;
```

```css
// frontend/src/components/ui/Button/Button.module.css
.button {
  padding: 0.5em 1em;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  text-decoration: none; /* For Link components styled as buttons */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease-in-out, opacity 0.2s;
}

/* Primary Variant */
.primary {
  background-color: #007bff; /* Example primary color */
  color: white;
}
.primary:hover:not(:disabled) {
  background-color: #0056b3;
}

/* Secondary Variant */
.secondary {
  background-color: #6c757d; /* Example secondary color */
  color: white;
}
.secondary:hover:not(:disabled) {
  background-color: #545b62;
}

/* Danger Variant */
.danger {
  background-color: #dc3545; /* Example danger color */
  color: white;
}
.danger:hover:not(:disabled) {
  background-color: #c82333;
}

/* Outline Variant */
.outlinePrimary {
  background-color: transparent;
  color: #007bff;
  border: 1px solid #007bff;
}
.outlinePrimary:hover:not(:disabled) {
  background-color: #007bff;
  color: white;
}


/* Sizes */
.small {
  font-size: 0.875rem;
  padding: 0.4em 0.8em;
}
.large {
  font-size: 1.125rem;
  padding: 0.6em 1.2em;
}


.button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
```

```tsx
// frontend/src/components/ui/Button/Button.tsx
import React from 'react';
import { Link, LinkProps } from 'react-router-dom';
import styles from './Button.module.css';

type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'outlinePrimary';
type ButtonSize = 'small' | 'medium' | 'large';

interface BaseButtonProps {
  children: React.ReactNode;
  onClick?: React.MouseEventHandler<HTMLButtonElement>;
  type?: 'button' | 'submit' | 'reset';
  variant?: ButtonVariant;
  size?: ButtonSize;
  disabled?: boolean;
  className?: string;
  fullWidth?: boolean;
}

// Props for when the component is used as a standard HTML button
interface HtmlButtonProps extends BaseButtonProps {
  as?: 'button';
  href?: never; // Ensure href is not allowed for 'button'
}

// Props for when the component is used as a React Router Link
interface RouterLinkProps extends BaseButtonProps, Omit<LinkProps, 'className' | 'style' | 'children'> {
  as: 'link';
  to: LinkProps['to']; // 'to' is required for Link
}

type ButtonProps = HtmlButtonProps | RouterLinkProps;

const Button: React.FC<ButtonProps> = ({
  as = 'button',
  children,
  onClick,
  type = 'button',
  variant = 'primary',
  size = 'medium',
  disabled = false,
  className = '',
  fullWidth = false,
  ...rest // Catches 'to' for Link and other props
}) => {
  const buttonClasses = [
    styles.button,
    styles[variant],
    styles[size],
    fullWidth ? styles.fullWidth : '',
    className,
  ].join(' ').trim();

  if (as === 'link') {
    const linkProps = rest as Omit<RouterLinkProps, keyof BaseButtonProps | 'as'>;
    return (
      <Link {...linkProps} className={buttonClasses} 
        // Prevent navigation on disabled link-like button
        onClick={(e) => { if (disabled) e.preventDefault(); }}
        aria-disabled={disabled}
      >
        {children}
      </Link>
    );
  }

  const btnProps = rest as Omit<HtmlButtonProps, keyof BaseButtonProps | 'as'>;
  return (
    <button
      type={type}
      className={buttonClasses}
      onClick={onClick}
      disabled={disabled}
      {...btnProps}
    >
      {children}
    </button>
  );
};

export default Button;
```

```css
// frontend/src/components/ui/Input/Input.module.css
.input {
  width: 100%;
  padding: 0.65rem 0.75rem; /* Slightly taller padding */
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 1rem;
  box-sizing: border-box; /* Important for width: 100% */
  transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.input:focus {
  border-color: #007bff; /* Example focus color */
  outline: none; /* Remove default outline */
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25); /* Bootstrap-like focus shadow */
}

.input[aria-invalid="true"] {
  border-color: #dc3545; /* Error color */
}

.input[aria-invalid="true"]:focus {
  border-color: #dc3545;
  box-shadow: 0 0 0 0.2rem rgba(220, 53, 69, 0.25);
}

.input::placeholder {
  color: #aaa;
}
```

```tsx
// frontend/src/components/ui/Input/Input.tsx
import React, { forwardRef, InputHTMLAttributes } from 'react';
import styles from './Input.module.css';

interface InputProps extends InputHTMLAttributes<HTMLInputElement> {
  // You can add custom props here if needed, e.g., error states, label, etc.
  // For react-hook-form, it's common to just spread {...register(...)}
  className?: string;
}

const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ className = '', type = 'text', ...props }, ref) => {
    const inputClasses = `${styles.input} ${className}`.trim();

    return (
      <input
        type={type}
        className={inputClasses}
        ref={ref}
        {...props}
      />
    );
  }
);

Input.displayName = 'Input'; // Helpful for debugging

export default Input;
```

```css
// frontend/src/components/ui/Modal/Modal.module.css
.overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent backdrop */
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000; /* Ensure it's on top */
}

.modal {
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  min-width: 300px;
  max-width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  position: relative; /* For positioning close button */
}

.closeButton {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  color: #888;
}
.closeButton:hover {
  color: #333;
}

.modalHeader {
  padding-bottom: 10px;
  margin-bottom: 15px;
  border-bottom: 1px solid #eee;
}

.modalTitle {
  margin: 0;
  font-size: 1.5rem;
}

.modalBody {
  margin-bottom: 15px;
}

.modalFooter {
  padding-top: 10px;
  border-top: 1px solid #eee;
  text-align: right; /* Align buttons to the right, common pattern */
}

.modalFooter button + button {
  margin-left: 0.5rem; /* Space between buttons in footer */
}
```

```tsx
// frontend/src/components/ui/Modal/Modal.tsx
import React, { useEffect } from 'react';
import ReactDOM from 'react-dom';
import styles from './Modal.module.css';
import Button from '../Button/Button'; // Optional: for styled buttons in footer

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  footerContent?: React.ReactNode; // Optional: to render buttons or other content in footer
}

const Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, children, footerContent }) => {
  useEffect(() => {
    const handleEscKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscKey);
    }

    return () => {
      document.removeEventListener('keydown', handleEscKey);
    };
  }, [isOpen, onClose]);

  if (!isOpen) {
    return null;
  }

  // Create a portal to render the modal outside the main app DOM tree
  // This is good for accessibility and stacking contexts
  const modalRoot = document.getElementById('root'); // Or a dedicated modal root element

  if (!modalRoot) {
    console.error("Modal root element not found. Make sure you have an element with id 'root' or a dedicated modal root.");
    return null; // Or render inline if portal root is not found, though less ideal
  }

  return ReactDOM.createPortal(
    <div className={styles.overlay} onClick={onClose} role="dialog" aria-modal="true" aria-labelledby={title ? "modal-title" : undefined}>
      <div className={styles.modal} onClick={(e) => e.stopPropagation()}> {/* Prevent closing when clicking inside modal */}
        <button onClick={onClose} className={styles.closeButton} aria-label="Close modal">&times;</button>
        
        {title && (
          <div className={styles.modalHeader}>
            <h2 id="modal-title" className={styles.modalTitle}>{title}</h2>
          </div>
        )}
        
        <div className={styles.modalBody}>
          {children}
        </div>
        
        {footerContent && (
          <div className={styles.modalFooter}>
            {footerContent}
          </div>
        )}
      </div>
    </div>,
    modalRoot
  );
};

export default Modal;
```

```css
// frontend/src/components/ui/Spinner/Spinner.module.css
.spinner {
  border: 4px solid rgba(0, 0, 0, 0.1);
  width: 36px;
  height: 36px;
  border-radius: 50%;
  border-left-color: #09f; /* Or your primary color */
  animation: spin 1s ease infinite;
  display: inline-block; /* Allows text to flow around or beside it if needed */
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* Centering wrapper for full-page spinner */
.spinnerWrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%; /* Or specific height if needed */
  width: 100%;
}
```

```tsx
// frontend/src/components/ui/Spinner/Spinner.tsx
import React from 'react';
import styles from './Spinner.module.css';

interface SpinnerProps {
  size?: number; // Optional: direct size in pixels
  color?: string; // Optional: direct color for the spinning part
  wrapperClassName?: string; // For custom wrapper styles if needed
}

const Spinner: React.FC<SpinnerProps> = ({ size, color, wrapperClassName }) => {
  const spinnerStyle: React.CSSProperties = {};
  if (size) {
    spinnerStyle.width = `${size}px`;
    spinnerStyle.height = `${size}px`;
    spinnerStyle.borderWidth = `${Math.max(2, Math.floor(size / 9))}px`; // Adjust border width based on size
  }
  if (color) {
    spinnerStyle.borderLeftColor = color;
  }

  return (
    <div className={wrapperClassName || styles.spinnerWrapper}>
      <div className={styles.spinner} style={spinnerStyle} role="status" aria-label="Loading...">
        {/* Visually hidden text for screen readers, though aria-label should suffice */}
        <span style={{ display: 'none' }}>Loading...</span> 
      </div>
    </div>
  );
};

export default Spinner;
```

```tsx
// frontend/src/contexts/AuthContext.tsx
import React, { createContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { User } from '@/types/authTypes';
import * as storage from '@/utils/localStorage';
import * as authService from '@/services/authService'; // For fetching user on token refresh

// Keys for localStorage
const TOKEN_KEY = 'koktajlove_authToken';
const USER_KEY = 'koktajlove_userData';

interface AuthContextType {
  user: User | null;
  token: string | null;
  isLoading: boolean; // For initial session loading
  isAuthenticated: boolean;
  login: (jwtToken: string, userData: User) => void;
  logout: () => void;
  // updateUser: (updatedUserData: Partial<User>) => void; // Optional: if user data can change
}

export const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true); // True until initial auth check is done

  useEffect(() => {
    const initializeAuth = async () => {
      setIsLoading(true);
      const storedToken = storage.getItem<string>(TOKEN_KEY);
      let storedUser = storage.getItem<User>(USER_KEY);

      if (storedToken) {
        setToken(storedToken);
        // Optionally, verify token with backend and fetch fresh user data
        // This is good practice in case user details (like roles) have changed
        // or if the token is stale/invalidated on the server.
        if (!storedUser) { // If user data is not in LS, try to fetch it
            try {
                // This assumes your apiClient is set up to use the token from localStorage
                // or you might need to pass it explicitly if this runs before apiClient is fully configured.
                // For simplicity, let's assume apiClient will pick up the token if set by setToken.
                const currentUser = await authService.getCurrentUser(); // Needs a service to get current user
                storedUser = currentUser;
                storage.setItem(USER_KEY, currentUser);
            } catch (error) {
                console.warn('Failed to fetch current user with stored token, logging out:', error);
                storage.removeItem(TOKEN_KEY);
                storage.removeItem(USER_KEY);
                setToken(null);
                setUser(null);
                // No return here, allow setIsLoading(false) to run
            }
        }
        setUser(storedUser);
      }
      setIsLoading(false);
    };

    initializeAuth();
  }, []);

  const login = useCallback((jwtToken: string, userData: User) => {
    storage.setItem(TOKEN_KEY, jwtToken);
    storage.setItem(USER_KEY, userData);
    setToken(jwtToken);
    setUser(userData);
  }, []);

  const logout = useCallback(() => {
    storage.removeItem(TOKEN_KEY);
    storage.removeItem(USER_KEY);
    setToken(null);
    setUser(null);
    // Optionally: redirect to login page or clear other app state
  }, []);

  // const updateUser = useCallback((updatedUserData: Partial<User>) => {
  //   setUser(prevUser => {
  //     if (prevUser) {
  //       const newUser = { ...prevUser, ...updatedUserData };
  //       storage.setItem(USER_KEY, newUser);
  //       return newUser;
  //     }
  //     return null;
  //   });
  // }, []);

  const isAuthenticated = !!token && !!user;

  const contextValue: AuthContextType = {
    user,
    token,
    isLoading,
    isAuthenticated,
    login,
    logout,
    // updateUser,
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};
```

```ts
// frontend/src/hooks/useApi.ts
import { useState, useCallback } from 'react';
// import apiClient from '../services/apiClient'; // Not strictly needed if apiFunc uses apiClient internally

interface UseApiState<T> {
  data: T | null;
  error: Error | any | null; // Can be more specific if error structure is known
  isLoading: boolean;
}

// P extends any[] allows for any number of arguments of any type for the apiFunc
type ApiFunction<T, P extends any[]> = (...args: P) => Promise<T>;

// The hook returns a tuple:
// 1. The memoized function to execute the API call.
// 2. The current state (data, error, isLoading).
export function useApi<T, P extends any[]>(
  apiFunc: ApiFunction<T, P>
): [ (...args: P) => Promise<T>, UseApiState<T> ] {
  const [state, setState] = useState<UseApiState<T>>({
    data: null,
    error: null,
    isLoading: false,
  });

  const execute = useCallback(async (...args: P): Promise<T> => {
    setState(prevState => ({ ...prevState, isLoading: true, error: null }));
    try {
      const result = await apiFunc(...args);
      setState({ data: result, error: null, isLoading: false });
      return result;
    } catch (err: any) {
      // Log the error for debugging purposes
      console.error('API call failed:', err.response?.data || err.message || err);
      // Store the error object. You might want to transform it or extract a message.
      // For now, storing the whole error object or response data if available.
      const errorToStore = err.response?.data || err;
      setState({ data: null, error: errorToStore, isLoading: false });
      throw errorToStore; // Re-throw the error so the caller can also handle it if needed
    }
  }, [apiFunc]);

  return [execute, state];
}
```

```ts
// frontend/src/hooks/useAuth.ts
import { useContext } from 'react';
import { AuthContext } from '@/contexts/AuthContext';

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider. Make sure your component is a descendant of AuthProvider.');
  }
  return context;
};
```

```css
// frontend/src/index.css
/*
  This file can be used for very basic, top-level CSS resets or defaults
  that Vite might include or that you want to apply before any component styles.
  Most global styles should go into styles/global.css.
*/

/* Example Reset (you might use a more comprehensive one like normalize.css or a modern reset) */
html, body, #root {
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  line-height: 1.5;
  background-color: #f8f9fa; /* A very light grey background */
  color: #212529; /* Dark text color for readability */
}

*, *::before, *::after {
  box-sizing: border-box;
}
```

```tsx
// frontend/src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App.tsx';
import './index.css'; // Base styles, resets
// styles/global.css is imported within App.tsx or App.css for now

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
);
```

```tsx
// frontend/src/pages/AddCocktailPage.tsx
import React from 'react';
import CocktailForm from '@/components/features/cocktails/CocktailForm';
import styles from './PageStyles.module.css'; // Optional: create a shared page style

const AddCocktailPage: React.FC = () => {
  return (
    <div className={styles.pageContainer}>
      {/* You can add a page-specific title or breadcrumbs here */}
      {/* <h1 className={styles.pageTitle}>Add New Cocktail</h1> */}
      <CocktailForm />
    </div>
  );
};

export default AddCocktailPage;
```

```tsx
// frontend/src/pages/CocktailDetailPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import * as cocktailService from '@/services/cocktailService';
import { CocktailWithDetails, Rating } from '@/types';
import Spinner from '@/components/ui/Spinner/Spinner';
import Button from '@/components/ui/Button/Button';
import RatingStars from '@/components/features/cocktails/RatingStars';
import { useAuth } from '@/hooks/useAuth';
import * as ratingService from '@/services/ratingService';
import * as favoriteService from '@/services/favoriteService';
import styles from './PageStyles.module.css'; // General page styles
import detailStyles from './CocktailDetailPage.module.css'; // Specific styles

const CocktailDetailPage: React.FC = () => {
  const { cocktailId } = useParams<{ cocktailId: string }>();
  const { user, isAuthenticated } = useAuth();
  const navigate = useNavigate();

  const [cocktail, setCocktail] = useState<CocktailWithDetails | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [userRating, setUserRating] = useState<number | null>(null);
  const [isFavorite, setIsFavorite] = useState(false);
  const [isRatingSubmitting, setIsRatingSubmitting] = useState(false);
  const [isFavoriteSubmitting, setIsFavoriteSubmitting] = useState(false);

  const fetchCocktailDetails = React.useCallback(async () => {
    if (!cocktailId) {
      setError('Cocktail ID is missing.');
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      const data = await cocktailService.getCocktailById(cocktailId);
      setCocktail(data);
      // If user is authenticated, fetch their rating for this cocktail
      if (isAuthenticated && user) {
        try {
          const ratingData = await ratingService.getUserRatingForCocktail(user.id, data.id);
          setUserRating(ratingData ? ratingData.score : null);
        } catch (ratingError: any) {
          // It's okay if user hasn't rated yet (404), don't show as page error
          if (ratingError.response?.status !== 404) {
            console.warn('Could not fetch user rating:', ratingError);
          }
        }
        try {
            const favStatus = await favoriteService.isCocktailFavorite(data.id);
            setIsFavorite(favStatus.is_favorite);
        } catch (favError) {
            console.warn('Could not fetch favorite status:', favError);
        }
      }
    } catch (err: any) {
      console.error('Failed to fetch cocktail details:', err);
      setError(err.response?.data?.detail || 'Failed to load cocktail details.');
    } finally {
      setIsLoading(false);
    }
  }, [cocktailId, isAuthenticated, user]);

  useEffect(() => {
    fetchCocktailDetails();
  }, [fetchCocktailDetails]);

  const handleRatingSubmit = async (newRating: number) => {
    if (!cocktail || !isAuthenticated || !user) return;
    setIsRatingSubmitting(true);
    try {
      await ratingService.rateCocktail(cocktail.id, newRating);
      setUserRating(newRating);
      // Optionally, re-fetch cocktail to update average_rating
      fetchCocktailDetails(); 
    } catch (err) {
      console.error('Failed to submit rating:', err);
      // Handle error display to user
    } finally {
      setIsRatingSubmitting(false);
    }
  };

  const handleToggleFavorite = async () => {
    if (!cocktail || !isAuthenticated) return;
    setIsFavoriteSubmitting(true);
    try {
      if (isFavorite) {
        await favoriteService.removeCocktailFromFavorites(cocktail.id);
        setIsFavorite(false);
      } else {
        await favoriteService.addCocktailToFavorites(cocktail.id);
        setIsFavorite(true);
      }
    } catch (err) {
      console.error('Failed to update favorite status:', err);
    } finally {
      setIsFavoriteSubmitting(false);
    }
  };
  
  const handleDeleteCocktail = async () => {
    if (!cocktail || !window.confirm(`Are you sure you want to delete "${cocktail.name}"?`)) {
      return;
    }
    try {
      await cocktailService.deleteCocktail(cocktail.id);
      navigate('/'); // Or to a list page
    } catch (err) {
      console.error('Failed to delete cocktail:', err);
      setError('Could not delete cocktail.');
    }
  };


  if (isLoading) {
    return <div className={styles.pageContainer}><Spinner /> <p>Loading cocktail...</p></div>;
  }

  if (error) {
    return <div className={`${styles.pageContainer} ${styles.error}`}>{error}</div>;
  }

  if (!cocktail) {
    return <div className={styles.pageContainer}>Cocktail not found.</div>;
  }
  
  const isOwner = isAuthenticated && user && user.id === cocktail.owner_id;
  const placeholderImage = 'https://via.placeholder.com/600x400.png?text=Cocktail';

  return (
    <div className={`${styles.pageContainer} ${detailStyles.cocktailDetailContainer}`}>
      <div className={detailStyles.header}>
        <h1 className={detailStyles.name}>{cocktail.name}</h1>
        {isOwner && (
            <div className={detailStyles.ownerActions}>
                <Button as="link" to={`/edit-cocktail/${cocktail.id}`} variant="secondary" size="small">
                    Edit
                </Button>
                <Button onClick={handleDeleteCocktail} variant="danger" size="small" disabled={isLoading}>
                    Delete
                </Button>
            </div>
        )}
      </div>

      <div className={detailStyles.mainContent}>
        <div className={detailStyles.imageContainer}>
            <img 
                src={cocktail.image_url || placeholderImage} 
                alt={cocktail.name} 
                className={detailStyles.image}
                onError={(e) => (e.currentTarget.src = placeholderImage)}
            />
        </div>
        <div className={detailStyles.info}>
            <p className={detailStyles.description}>{cocktail.description}</p>

            <div className={detailStyles.ratingSection}>
                <h4>Average Rating:</h4>
                {cocktail.average_rating !== null && cocktail.average_rating !== undefined ? (
                    <>
                        <RatingStars rating={cocktail.average_rating} readOnly />
                        <span> ({cocktail.average_rating.toFixed(1)} / 5)</span>
                    </>
                ) : (
                    <p>Not rated yet.</p>
                )}
            </div>

            {isAuthenticated && (
            <div className={detailStyles.userInteractionSection}>
                <div className={detailStyles.userRatingSection}>
                    <h4>Your Rating:</h4>
                    <RatingStars
                        rating={userRating || 0}
                        onRatingChange={handleRatingSubmit}
                        readOnly={isRatingSubmitting}
                    />
                    {isRatingSubmitting && <Spinner size={20} />}
                </div>
                <Button
                    onClick={handleToggleFavorite}
                    disabled={isFavoriteSubmitting}
                    variant={isFavorite ? "secondary" : "primary"}
                    className={detailStyles.favoriteButton}
                >
                    {isFavoriteSubmitting ? <Spinner size={18}/> : (isFavorite ? 'Unfavorite' : 'Favorite')}
                </Button>
            </div>
            )}


            <h4>Ingredients:</h4>
            <ul className={detailStyles.ingredientList}>
            {cocktail.ingredients.map(item => (
                <li key={item.ingredient.id}>
                {item.ingredient.name}: {item.quantity} {item.unit}
                </li>
            ))}
            </ul>

            <h4>Instructions:</h4>
            <p className={detailStyles.instructions}>{cocktail.instructions}</p>

            {cocktail.tags && cocktail.tags.length > 0 && (
            <>
                <h4>Tags:</h4>
                <div className={detailStyles.tagList}>
                {cocktail.tags.map(tag => (
                    <span key={tag.id} className={detailStyles.tag}>{tag.name}</span>
                ))}
                </div>
            </>
            )}
            <p className={detailStyles.metaInfo}>
                Added by: User ID {cocktail.owner_id} | 
                Last updated: {new Date(cocktail.updated_at).toLocaleDateString()}
            </p>
        </div>
      </div>
      <Link to="/" className={styles.backLink}>Back to list</Link>
    </div>
  );
};

// Add CocktailDetailPage.module.css
// /* frontend/src/pages/CocktailDetailPage.module.css */
// .cocktailDetailContainer { /* Styles for overall container */ }
// .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
// .name { font-size: 2.5rem; color: #333; }
// .ownerActions button { margin-left: 0.5rem; }
// .mainContent { display: grid; grid-template-columns: 1fr; gap: 2rem; }
// @media (min-width: 768px) { .mainContent { grid-template-columns: 300px 1fr; } }
// .imageContainer {}
// .image { width: 100%; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
// .info {}
// .description { font-size: 1.1rem; color: #555; margin-bottom: 1rem; }
// .ratingSection, .userInteractionSection, .userRatingSection { margin-bottom: 1rem; }
// .userInteractionSection { display: flex; align-items: center; gap: 1rem; margin-top: 1rem; }
// .favoriteButton {}
// .ingredientList { list-style: disc; padding-left: 20px; margin-bottom: 1rem; }
// .instructions { white-space: pre-wrap; /* Preserve formatting */ margin-bottom: 1rem; }
// .tagList { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; }
// .tag { background-color: #e9ecef; padding: 0.25rem 0.75rem; border-radius: 15px; font-size: 0.9rem; }
// .metaInfo { font-size: 0.85rem; color: #777; margin-top: 1.5rem; }

export default CocktailDetailPage;
```
*Dodaj poniższy kod do pliku `frontend/src/pages/CocktailDetailPage.module.css` (lub utwórz go, jeśli nie istnieje):*
```css
/* frontend/src/pages/CocktailDetailPage.module.css */
.cocktailDetailContainer {
  /* Styles for overall container */
  background-color: #fff;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.05);
}
.header { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin-bottom: 1.5rem; 
  border-bottom: 1px solid #eee;
  padding-bottom: 1rem;
}
.name { 
  font-size: 2.5rem; 
  color: #333; 
  margin: 0;
}
.ownerActions button { 
  margin-left: 0.5rem; 
}
.mainContent { 
  display: grid; 
  grid-template-columns: 1fr; 
  gap: 2rem; 
}
@media (min-width: 768px) { 
  .mainContent { 
    grid-template-columns: minmax(250px, 300px) 1fr; 
  } 
}
.imageContainer {
  /* Styles for image container */
}
.image { 
  width: 100%; 
  height: auto;
  max-height: 400px;
  object-fit: cover;
  border-radius: 8px; 
  box-shadow: 0 4px 8px rgba(0,0,0,0.1); 
}
.info {
  /* Styles for info section */
}
.description { 
  font-size: 1.1rem; 
  color: #555; 
  margin-bottom: 1.5rem; 
  line-height: 1.6;
}
.ratingSection, .userInteractionSection, .userRatingSection { 
  margin-bottom: 1.5rem; 
}
.userInteractionSection { 
  display: flex; 
  flex-wrap: wrap;
  align-items: center; 
  gap: 1rem; 
  margin-top: 1rem; 
  padding: 1rem;
  background-color: #f9f9f9;
  border-radius: 4px;
}
.userRatingSection h4, .ratingSection h4 {
  margin-bottom: 0.5rem;
  font-size: 1rem;
  color: #444;
}
.favoriteButton {
  /* Styles for favorite button */
}
.ingredientList { 
  list-style: disc; 
  padding-left: 20px; 
  margin-bottom: 1.5rem; 
}
.ingredientList li {
  margin-bottom: 0.25rem;
}
.instructions { 
  white-space: pre-wrap; /* Preserve formatting */ 
  margin-bottom: 1.5rem; 
  background-color: #fdfdfd;
  padding: 1rem;
  border: 1px solid #eee;
  border-radius: 4px;
  line-height: 1.7;
}
.tagList { 
  display: flex; 
  flex-wrap: wrap; 
  gap: 0.5rem; 
  margin-bottom: 1.5rem; 
}
.tag { 
  background-color: #e9ecef; 
  color: #495057;
  padding: 0.25rem 0.75rem; 
  border-radius: 15px; 
  font-size: 0.9rem; 
}
.metaInfo { 
  font-size: 0.85rem; 
  color: #777; 
  margin-top: 1.5rem; 
  text-align: right;
  border-top: 1px solid #eee;
  padding-top: 0.75rem;
}

h4 {
    font-size: 1.2rem;
    color: #333;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
}
```


```tsx
// frontend/src/pages/EditCocktailPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import CocktailForm from '@/components/features/cocktails/CocktailForm';
import * as cocktailService from '@/services/cocktailService';
import { CocktailWithDetails } from '@/types';
import Spinner from '@/components/ui/Spinner/Spinner';
import { useAuth } from '@/hooks/useAuth';
import styles from './PageStyles.module.css';

const EditCocktailPage: React.FC = () => {
  const { cocktailId } = useParams<{ cocktailId: string }>();
  const navigate = useNavigate();
  const { user, isLoading: authLoading } = useAuth();

  const [cocktail, setCocktail] = useState<CocktailWithDetails | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!cocktailId) {
      setError('Cocktail ID is missing.');
      setIsLoading(false);
      return;
    }
    if (authLoading) return; // Wait for auth state to resolve

    const fetchCocktail = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const data = await cocktailService.getCocktailById(cocktailId);
        // Authorization check: only owner can edit
        if (!user || data.owner_id !== user.id) {
          setError('You are not authorized to edit this cocktail.');
          // setTimeout(() => navigate('/'), 3000); // Redirect after a delay
          setCocktail(null); // Clear cocktail data
        } else {
          setCocktail(data);
        }
      } catch (err: any) {
        console.error('Failed to fetch cocktail for editing:', err);
        setError(err.response?.data?.detail || 'Failed to load cocktail data.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchCocktail();
  }, [cocktailId, user, authLoading, navigate]);

  const handleUpdateSuccess = (updatedCocktail: CocktailWithDetails) => {
    // Optionally show a success message
    navigate(`/cocktail/${updatedCocktail.id}`);
  };

  if (isLoading || authLoading) {
    return <div className={styles.pageContainer}><Spinner /><p>Loading cocktail for editing...</p></div>;
  }

  if (error) {
    return <div className={`${styles.pageContainer} ${styles.error}`}>{error}</div>;
  }

  if (!cocktail) {
    // This case might be hit if user is not authorized or cocktail not found after loading
    return <div className={styles.pageContainer}>Cocktail not available for editing.</div>;
  }

  return (
    <div className={styles.pageContainer}>
      {/* <h1 className={styles.pageTitle}>Edit "{cocktail.name}"</h1> */}
      <CocktailForm cocktail={cocktail} onSubmitSuccess={handleUpdateSuccess} />
    </div>
  );
};

export default EditCocktailPage;
```

```tsx
// frontend/src/pages/HomePage.tsx
import React, { useEffect, useState } from 'react';
import CocktailList from '@/components/features/cocktails/CocktailList';
import * as cocktailService from '@/services/cocktailService';
import { CocktailWithDetails } from '@/types';
// import { useApi } from '@/hooks/useApi'; // Alternative using useApi
import styles from './PageStyles.module.css'; // Optional: create a shared page style for consistency
import Spinner from '@/components/ui/Spinner/Spinner';

const HomePage: React.FC = () => {
  const [cocktails, setCocktails] = useState<CocktailWithDetails[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  // Example using useState for loading/error
  useEffect(() => {
    const fetchCocktails = async () => {
      setIsLoading(true);
      setError(null);
      try {
        // Fetch only public cocktails, or all if no filter applied by default on backend
        const data = await cocktailService.getCocktails({ is_public: true }); 
        setCocktails(data);
      } catch (err: any) {
        console.error('Failed to fetch cocktails:', err);
        setError(err);
      } finally {
        setIsLoading(false);
      }
    };
    fetchCocktails();
  }, []);

  // // Example using useApi custom hook
  // const [fetchCocktails, { data: cocktailsData, isLoading, error }] = useApi(
  //   () => cocktailService.getCocktails({ is_public: true })
  // );
  // useEffect(() => {
  //   fetchCocktails();
  // }, [fetchCocktails]);
  // const cocktails = cocktailsData || [];


  return (
    <div className={styles.pageContainer}>
      <h1 className={styles.pageTitle}>Welcome to KoktajLOVE!</h1>
      <p className={styles.pageSubtitle}>Discover and share amazing cocktail recipes.</p>
      
      {/* TODO: Add search/filter bar component here */}
      {/* <CocktailFilters onFilterChange={handleFilterChange} /> */}

      {isLoading && <div className={styles.centeredMessage}><Spinner /> <p>Loading cocktails...</p></div>}
      {error && <p className={`${styles.centeredMessage} ${styles.error}`}>Failed to load cocktails: {error.message}</p>}
      {!isLoading && !error && (
        <CocktailList cocktails={cocktails} isLoading={false} error={null} />
      )}
    </div>
  );
};

export default HomePage;
```

```tsx
// frontend/src/pages/LoginPage.tsx
import React from 'react';
import { Link, useLocation } from 'react-router-dom';
import LoginForm from '@/components/features/auth/LoginForm';
import styles from './PageStyles.module.css'; // Optional: create a shared page style

const LoginPage: React.FC = () => {
  const location = useLocation();
  const message = location.state?.message;

  return (
    <div className={styles.pageContainer}>
      {/* <h1 className={styles.pageTitle}>Login</h1> */}
      {message && <p className={styles.successMessage}>{message}</p>}
      <LoginForm />
      <p className={styles.authRedirectText}>
        Don't have an account? <Link to="/register">Register here</Link>
      </p>
    </div>
  );
};

export default LoginPage;
```

```tsx
// frontend/src/pages/MyFavoritesPage.tsx
import React, { useEffect, useState } from 'react';
import CocktailList from '@/components/features/cocktails/CocktailList';
import * as favoriteService from '@/services/favoriteService';
import { CocktailWithDetails } from '@/types';
import { useAuth } from '@/hooks/useAuth';
import Spinner from '@/components/ui/Spinner/Spinner';
import styles from './PageStyles.module.css';

const MyFavoritesPage: React.FC = () => {
  const { user, isLoading: authLoading } = useAuth();
  const [favoriteCocktails, setFavoriteCocktails] = useState<CocktailWithDetails[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    if (authLoading) return; // Wait for auth to resolve

    if (!user) {
      // Should be handled by ProtectedRoute, but as a fallback:
      setError(new Error('You must be logged in to view your favorites.'));
      setIsLoading(false);
      return;
    }

    const fetchFavorites = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const data = await favoriteService.getFavoriteCocktails();
        setFavoriteCocktails(data);
      } catch (err: any) {
        console.error('Failed to fetch favorite cocktails:', err);
        setError(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchFavorites();
  }, [user, authLoading]);

  return (
    <div className={styles.pageContainer}>
      <h1 className={styles.pageTitle}>My Favorite Cocktails</h1>
      
      {isLoading || authLoading ? (
        <div className={styles.centeredMessage}><Spinner /> <p>Loading your favorites...</p></div>
      ) : error ? (
        <p className={`${styles.centeredMessage} ${styles.error}`}>
          Failed to load favorites: {error.message}
        </p>
      ) : favoriteCocktails.length === 0 ? (
        <p className={styles.centeredMessage}>You haven't added any cocktails to your favorites yet.</p>
      ) : (
        <CocktailList cocktails={favoriteCocktails} isLoading={false} error={null} />
      )}
    </div>
  );
};

export default MyFavoritesPage;
```

```tsx
// frontend/src/pages/NotFoundPage.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import styles from './PageStyles.module.css'; // Optional: create a shared page style

const NotFoundPage: React.FC = () => {
  return (
    <div className={`${styles.pageContainer} ${styles.centeredMessage}`}>
      <h1 className={styles.pageTitle}>404 - Page Not Found</h1>
      <p>Oops! The page you are looking for does not exist.</p>
      <p>
        You can <Link to="/" className={styles.styledLink}>return to the homepage</Link>.
      </p>
    </div>
  );
};

export default NotFoundPage;
```

```tsx
// frontend/src/pages/ProfilePage.tsx
import React from 'react';
import { useAuth } from '@/hooks/useAuth';
import ProfileDetails from '@/components/features/profile/ProfileDetails';
import UserCocktailList from '@/components/features/profile/UserCocktailList';
// import Button from '@/components/ui/Button/Button'; // For Edit Profile button
import styles from './PageStyles.module.css'; // Optional: create a shared page style

const ProfilePage: React.FC = () => {
  const { user, isLoading: authLoading } = useAuth();

  // ProtectedRoute should handle unauthenticated users,
  // but this is an additional safeguard.
  if (authLoading) {
    return <div className={styles.pageContainer}><p>Loading profile...</p></div>;
  }

  if (!user) {
    // This should ideally not be reached if ProtectedRoute is working correctly.
    return <div className={styles.pageContainer}><p>Please log in to view your profile.</p></div>;
  }

  return (
    <div className={styles.pageContainer}>
      {/* <h1 className={styles.pageTitle}>My Profile</h1> */}
      <ProfileDetails user={user} isLoading={authLoading} />
      
      {/* Future: Edit Profile Button */}
      {/* <div style={{ marginTop: '1rem', textAlign: 'center' }}>
        <Button as="link" to="/profile/edit" variant="secondary">
          Edit Profile
        </Button>
      </div> */}

      <UserCocktailList userId={user.id} />
    </div>
  );
};

export default ProfilePage;
```

```tsx
// frontend/src/pages/RegisterPage.tsx
import React from 'react';
import { Link } from 'react-router-dom';
import RegisterForm from '@/components/features/auth/RegisterForm';
import styles from './PageStyles.module.css'; // Optional: create a shared page style

const RegisterPage: React.FC = () => {
  return (
    <div className={styles.pageContainer}>
      {/* <h1 className={styles.pageTitle}>Create Account</h1> */}
      <RegisterForm />
      <p className={styles.authRedirectText}>
        Already have an account? <Link to="/login">Login here</Link>
      </p>
    </div>
  );
};

export default RegisterPage;
```

*Utwórz plik `frontend/src/pages/PageStyles.module.css` z poniższą zawartością (lub dostosuj według potrzeb):*
```css
/* frontend/src/pages/PageStyles.module.css */
.pageContainer {
  padding: 1rem 1.5rem; /* Default padding for pages */
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}

.pageTitle {
  font-size: 2rem; /* Consistent title size */
  margin-bottom: 1.5rem;
  color: #333;
  text-align: center;
  border-bottom: 1px solid #eee;
  padding-bottom: 0.75rem;
}

.pageSubtitle {
  font-size: 1.1rem;
  color: #666;
  text-align: center;
  margin-bottom: 2rem;
}

.centeredMessage {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 200px; /* Ensure some space for the message */
  text-align: center;
  color: #555;
}

.centeredMessage p {
    margin-top: 1rem;
}

.error {
  color: #dc3545; /* Bootstrap danger color */
  font-weight: bold;
}

.successMessage {
  background-color: #d4edda; /* Bootstrap success background */
  color: #155724; /* Bootstrap success text */
  border: 1px solid #c3e6cb; /* Bootstrap success border */
  padding: 0.75rem 1.25rem;
  margin-bottom: 1rem;
  border-radius: 0.25rem;
  text-align: center;
}

.authRedirectText {
  text-align: center;
  margin-top: 1.5rem;
  font-size: 0.95rem;
}

.authRedirectText a {
  color: #007bff;
  text-decoration: underline;
}

.styledLink {
  color: #007bff;
  text-decoration: none;
  font-weight: bold;
}
.styledLink:hover {
  text-decoration: underline;
}

.backLink {
  display: inline-block;
  margin-top: 1.5rem;
  color: #007bff;
  text-decoration: none;
}
.backLink:hover {
  text-decoration: underline;
}
```

```tsx
// frontend/src/router/AppRoutes.tsx
import React from 'react';
import { Routes, Route, Navigate } from 'react-router-dom';

// Layout
import MainLayout from '@/components/layout/MainLayout/MainLayout';

// Pages
import HomePage from '@/pages/HomePage';
import LoginPage from '@/pages/LoginPage';
import RegisterPage from '@/pages/RegisterPage';
import CocktailDetailPage from '@/pages/CocktailDetailPage';
import AddCocktailPage from '@/pages/AddCocktailPage';
import EditCocktailPage from '@/pages/EditCocktailPage';
import ProfilePage from '@/pages/ProfilePage';
import MyFavoritesPage from '@/pages/MyFavoritesPage';
import NotFoundPage from '@/pages/NotFoundPage';

// Protected Route
import ProtectedRoute from './ProtectedRoute';

// A list of all available cocktails (could be same as HomePage or a dedicated page)
const AllCocktailsPage = () => <HomePage />; // Example: HomePage lists all public cocktails

const AppRoutes: React.FC = () => (
  <Routes>
    <Route element={<MainLayout />}>
      {/* Public Routes */}
      <Route path="/" element={<HomePage />} />
      <Route path="/cocktails" element={<AllCocktailsPage />} /> {/* For a general cocktail listing */}
      <Route path="/login" element={<LoginPage />} />
      <Route path="/register" element={<RegisterPage />} />
      <Route path="/cocktail/:cocktailId" element={<CocktailDetailPage />} />
      
      {/* Protected Routes */}
      <Route element={<ProtectedRoute />}>
        <Route path="/add-cocktail" element={<AddCocktailPage />} />
        <Route path="/profile" element={<ProfilePage />} />
        {/* <Route path="/profile/edit" element={<EditProfilePage />} /> Placeholder */}
        <Route path="/my-favorites" element={<MyFavoritesPage />} />
        <Route path="/edit-cocktail/:cocktailId" element={<EditCocktailPage />} />
      </Route>

      {/* Not Found */}
      <Route path="/not-found" element={<NotFoundPage />} />
      <Route path="*" element={<Navigate to="/not-found" replace />} />
    </Route>
  </Routes>
);

export default AppRoutes;
```

```tsx
// frontend/src/router/ProtectedRoute.tsx
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';
import Spinner from '@/components/ui/Spinner/Spinner'; // Assuming a Spinner component

const ProtectedRoute: React.FC = () => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    // Show a loading indicator while checking auth status
    // This prevents a flicker or premature redirect if auth state is still loading
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
        <Spinner />
        <p style={{ marginLeft: '10px' }}>Verifying authentication...</p>
      </div>
    );
  }

  if (!isAuthenticated) {
    // User not authenticated, redirect to login page
    // Save the current location so we can redirect back after login
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // User is authenticated, render the child route component
  return <Outlet />;
};

export default ProtectedRoute;
```

```ts
// frontend/src/services/apiClient.ts
import axios, { InternalAxiosRequestConfig } from 'axios';
import * as storage from '@/utils/localStorage'; // For getting token

const VITE_API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1';
const TOKEN_KEY = 'koktajlove_authToken'; // Consistent key with AuthContext

const apiClient = axios.create({
  baseURL: VITE_API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request Interceptor: Adds the auth token to requests if available
apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const token = storage.getItem<string>(TOKEN_KEY);
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response Interceptor (Optional): Handle global errors like 401
apiClient.interceptors.response.use(
  (response) => {
    return response;
  },
  (error) => {
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      console.error('API Error Status:', error.response.status);
      console.error('API Error Data:', error.response.data);

      if (error.response.status === 401) {
        // Unauthorized: Token might be invalid or expired
        // Here you could trigger a logout action or redirect to login
        // Be careful with circular dependencies if importing AuthContext/logout directly
        // One common pattern is to dispatch a custom event that AuthContext listens to.
        console.warn('Unauthorized access (401). Token may be invalid or expired.');
        // Example: Firing a custom event
        // window.dispatchEvent(new CustomEvent('auth-error-401'));
        // Or, if a simple redirect is enough:
        // storage.removeItem(TOKEN_KEY);
        // storage.removeItem('koktajlove_userData'); // Also clear user data
        // window.location.href = '/login'; // Force reload to clear state
      }
    } else if (error.request) {
      // The request was made but no response was received
      console.error('API No Response:', error.request);
    } else {
      // Something happened in setting up the request that triggered an Error
      console.error('API Request Setup Error:', error.message);
    }
    return Promise.reject(error);
  }
);

export default apiClient;
```

```ts
// frontend/src/services/authService.ts
import apiClient from './apiClient';
import { LoginCredentials, RegisterData, User, TokenResponse } from '@/types/authTypes';

interface LoginResponse {
  access_token: string; // Match backend response for token
  token_type: string; // Typically "bearer"
  user: User; // Assuming backend returns user details on login
}

/**
 * Logs in a user.
 * @param credentials - The user's login credentials (username/email and password).
 * @returns A promise that resolves to an object containing the JWT and user data.
 */
export const loginUser = async (credentials: LoginCredentials): Promise<{ token: string; user: User }> => {
  const response = await apiClient.post<LoginResponse>('/auth/login', credentials);
  // The backend should return the user object directly or we might need another call.
  // Assuming it returns `access_token` and `user` object.
  return { token: response.data.access_token, user: response.data.user };
};

/**
 * Registers a new user.
 * @param data - The user's registration data (email, password, username).
 * @returns A promise that resolves to the created user's data (excluding sensitive info).
 */
export const registerUser = async (data: RegisterData): Promise<User> => {
  const response = await apiClient.post<User>('/auth/register', data);
  return response.data;
};

/**
 * Fetches the current authenticated user's data.
 * Requires a valid JWT to be sent in the Authorization header (handled by apiClient interceptor).
 * @returns A promise that resolves to the current user's data.
 */
export const getCurrentUser = async (): Promise<User> => {
  const response = await apiClient.get<User>('/users/me');
  return response.data;
};

/**
 * (Optional) Refreshes the JWT token if your backend supports it.
 * @param refreshToken - The refresh token.
 * @returns A promise that resolves to the new token data.
 */
export const refreshToken = async (/* refreshToken: string */): Promise<TokenResponse> => {
  // This is a placeholder. Your backend might have a different endpoint or mechanism.
  // const response = await apiClient.post<TokenResponse>('/auth/refresh-token', { refresh_token: refreshToken });
  // return response.data;
  throw new Error('Refresh token functionality not implemented yet.');
};
```

```ts
// frontend/src/services/cocktailService.ts
import apiClient from './apiClient';
import { 
  CocktailWithDetails, 
  CocktailCreate, 
  CocktailUpdate,
  PaginatedResponse // If using pagination
} from '@/types/cocktailTypes';
import { CommonQueryPaginationParams } from '@/types/commonTypes';


// Define a type for filter parameters if you have them
export interface CocktailFilters extends CommonQueryPaginationParams {
  name?: string;
  tag_ids?: number[];
  ingredient_ids?: number[];
  owner_id?: number;
  is_public?: boolean;
  // Add other filterable fields as needed
}

/**
 * Fetches a list of cocktails, optionally with filters and pagination.
 * @param params - Optional filter and pagination parameters.
 * @returns A promise that resolves to an array of cocktails or a paginated response.
 */
export const getCocktails = async (params?: CocktailFilters): Promise<CocktailWithDetails[] | PaginatedResponse<CocktailWithDetails>> => {
  // If your backend returns a simple array:
  // const response = await apiClient.get<CocktailWithDetails[]>('/cocktails/', { params });
  // return response.data;

  // If your backend returns a paginated structure:
  const response = await apiClient.get<PaginatedResponse<CocktailWithDetails>>('/cocktails/', { params });
  // If the backend doesn't always return PaginatedResponse (e.g. for non-paginated filters)
  // you might need to check the response structure or always expect one type.
  // For now, assuming it might be one or the other based on params.
  // A more robust way is to always expect PaginatedResponse and extract items.
  // Example: return response.data.items if always paginated.
  // For now, this example assumes it could be either.
  if ('items' in response.data && 'total' in response.data) {
    return response.data as PaginatedResponse<CocktailWithDetails>;
  }
  return response.data as CocktailWithDetails[]; // Fallback if not clearly paginated by structure
};

/**
 * Fetches a single cocktail by its ID.
 * @param id - The ID of the cocktail.
 * @returns A promise that resolves to the cocktail details.
 */
export const getCocktailById = async (id: number | string): Promise<CocktailWithDetails> => {
  const response = await apiClient.get<CocktailWithDetails>(`/cocktails/${id}`);
  return response.data;
};

/**
 * Creates a new cocktail.
 * @param data - The data for the new cocktail.
 * @returns A promise that resolves to the created cocktail details.
 */
export const createCocktail = async (data: CocktailCreate): Promise<CocktailWithDetails> => {
  const response = await apiClient.post<CocktailWithDetails>('/cocktails/', data);
  return response.data;
};

/**
 * Updates an existing cocktail.
 * @param id - The ID of the cocktail to update.
 * @param data - The data to update the cocktail with.
 * @returns A promise that resolves to the updated cocktail details.
 */
export const updateCocktail = async (id: number | string, data: CocktailUpdate): Promise<CocktailWithDetails> => {
  const response = await apiClient.put<CocktailWithDetails>(`/cocktails/${id}`, data);
  return response.data;
};

/**
 * Deletes a cocktail.
 * @param id - The ID of the cocktail to delete.
 * @returns A promise that resolves when the cocktail is deleted.
 */
export const deleteCocktail = async (id: number | string): Promise<void> => {
  await apiClient.delete(`/cocktails/${id}`);
};

// Add other cocktail-related service functions as needed, e.g.:
// - searchCocktails
// - getCocktailsByTags
// - getCocktailsByIngredients
```

```ts
// frontend/src/services/favoriteService.ts
import apiClient from './apiClient';
import { CocktailWithDetails } from '@/types/cocktailTypes';
import { User } from '@/types/authTypes'; // If needed for specific user favorites

interface FavoriteStatusResponse {
  is_favorite: boolean;
  cocktail_id: number;
  // user_id might also be part of the response
}

/**
 * Fetches the list of favorite cocktails for the currently authenticated user.
 * @returns A promise that resolves to an array of favorite cocktails.
 */
export const getFavoriteCocktails = async (): Promise<CocktailWithDetails[]> => {
  // Endpoint might be /users/me/favorites or /favorites/
  const response = await apiClient.get<CocktailWithDetails[]>('/users/me/favorites'); 
  return response.data;
};

/**
 * Adds a cocktail to the user's favorites.
 * @param cocktailId - The ID of the cocktail to add.
 * @returns A promise that resolves when the cocktail is added (response might be minimal or the favorite entry).
 */
export const addCocktailToFavorites = async (cocktailId: number | string): Promise<any> => {
  // Endpoint might be /cocktails/{cocktailId}/favorite or /favorites/
  const response = await apiClient.post(`/cocktails/${cocktailId}/favorite`);
  return response.data; // Or handle as void if no meaningful data returned
};

/**
 * Removes a cocktail from the user's favorites.
 * @param cocktailId - The ID of the cocktail to remove.
 * @returns A promise that resolves when the cocktail is removed.
 */
export const removeCocktailFromFavorites = async (cocktailId: number | string): Promise<void> => {
  await apiClient.delete(`/cocktails/${cocktailId}/favorite`);
};

/**
 * Checks if a specific cocktail is in the user's favorites.
 * @param cocktailId - The ID of the cocktail to check.
 * @returns A promise that resolves to an object indicating favorite status.
 */
export const isCocktailFavorite = async (cocktailId: number | string): Promise<FavoriteStatusResponse> => {
    const response = await apiClient.get<FavoriteStatusResponse>(`/cocktails/${cocktailId}/is-favorite`);
    return response.data;
};

// If you need to manage favorites for a specific user (e.g., admin viewing another user's favorites)
// you might have functions like:
// export const getUserFavorites = async (userId: number | string): Promise<CocktailWithDetails[]> => {
//   const response = await apiClient.get<CocktailWithDetails[]>(`/users/${userId}/favorites`);
//   return response.data;
// };
```

```ts
// frontend/src/services/ingredientService.ts
import apiClient from './apiClient';
import { Ingredient, IngredientCreate, IngredientUpdate, PaginatedResponse } from '@/types/cocktailTypes'; // Assuming Ingredient types are in cocktailTypes
import { CommonQueryPaginationParams } from '@/types/commonTypes';


export interface IngredientFilters extends CommonQueryPaginationParams {
  name?: string;
  // Add other filterable fields as needed
}
/**
 * Fetches a list of ingredients.
 * @param params - Optional filter and pagination parameters.
 * @returns A promise that resolves to an array of ingredients or a paginated response.
 */
export const getIngredients = async (params?: IngredientFilters): Promise<Ingredient[] | PaginatedResponse<Ingredient>> => {
  const response = await apiClient.get<Ingredient[] | PaginatedResponse<Ingredient>>('/ingredients/', { params });
  // Similar to cocktailService, adapt based on whether your API always returns paginated or simple array
  if ('items' in response.data && 'total' in response.data) {
    return response.data as PaginatedResponse<Ingredient>;
  }
  return response.data as Ingredient[];
};

/**
 * Fetches a single ingredient by its ID.
 * @param id - The ID of the ingredient.
 * @returns A promise that resolves to the ingredient details.
 */
export const getIngredientById = async (id: number | string): Promise<Ingredient> => {
  const response = await apiClient.get<Ingredient>(`/ingredients/${id}`);
  return response.data;
};

/**
 * Creates a new ingredient. (Primarily for admin users)
 * @param data - The data for the new ingredient.
 * @returns A promise that resolves to the created ingredient.
 */
export const createIngredient = async (data: IngredientCreate): Promise<Ingredient> => {
  const response = await apiClient.post<Ingredient>('/ingredients/', data);
  return response.data;
};

/**
 * Updates an existing ingredient. (Primarily for admin users)
 * @param id - The ID of the ingredient to update.
 * @param data - The data to update the ingredient with.
 * @returns A promise that resolves to the updated ingredient.
 */
export const updateIngredient = async (id: number | string, data: IngredientUpdate): Promise<Ingredient> => {
  const response = await apiClient.put<Ingredient>(`/ingredients/${id}`, data);
  return response.data;
};

/**
 * Deletes an ingredient. (Primarily for admin users)
 * @param id - The ID of the ingredient to delete.
 * @returns A promise that resolves when the ingredient is deleted.
 */
export const deleteIngredient = async (id: number | string): Promise<void> => {
  await apiClient.delete(`/ingredients/${id}`);
};
```

```ts
// frontend/src/services/ratingService.ts
import apiClient from './apiClient';
import { Rating, RatingCreate, RatingUpdate } from '@/types/cocktailTypes'; // Assuming Rating types are in cocktailTypes

/**
 * Submits or updates a rating for a cocktail.
 * @param cocktailId - The ID of the cocktail being rated.
 * @param score - The rating score (e.g., 1-5).
 * @returns A promise that resolves to the created or updated rating.
 */
export const rateCocktail = async (cocktailId: number | string, score: number): Promise<Rating> => {
  // The backend might use a POST to /cocktails/{cocktailId}/ratings or a general /ratings endpoint.
  // Adjust the endpoint and payload (RatingCreate) as needed.
  const payload: RatingCreate = { score, cocktail_id: Number(cocktailId) }; // cocktail_id might be implicit from URL
  const response = await apiClient.post<Rating>(`/cocktails/${cocktailId}/rate`, payload);
  return response.data;
};

/**
 * Fetches all ratings for a specific cocktail.
 * @param cocktailId - The ID of the cocktail.
 * @returns A promise that resolves to an array of ratings for the cocktail.
 */
export const getRatingsForCocktail = async (cocktailId: number | string): Promise<Rating[]> => {
  const response = await apiClient.get<Rating[]>(`/cocktails/${cocktailId}/ratings`);
  return response.data;
};

/**
 * Fetches a specific rating by its ID (if ratings have their own IDs and endpoint).
 * @param ratingId - The ID of the rating.
 * @returns A promise that resolves to the rating details.
 */
export const getRatingById = async (ratingId: number | string): Promise<Rating> => {
  const response = await apiClient.get<Rating>(`/ratings/${ratingId}`); // Example endpoint
  return response.data;
};

/**
 * Updates an existing rating.
 * @param ratingId - The ID of the rating to update.
 *   (Or cocktailId if user can only have one rating per cocktail, then use rateCocktail/PUT)
 * @param data - The data to update the rating with (e.g., new score).
 * @returns A promise that resolves to the updated rating.
 */
export const updateRating = async (ratingId: number | string, data: RatingUpdate): Promise<Rating> => {
  const response = await apiClient.put<Rating>(`/ratings/${ratingId}`, data); // Example endpoint
  return response.data;
};

/**
 * Deletes a rating.
 * @param ratingId - The ID of the rating to delete.
 *   (Or cocktailId if user wants to remove their rating for a cocktail)
 * @returns A promise that resolves when the rating is deleted.
 */
export const deleteRating = async (ratingId: number | string): Promise<void> => {
  await apiClient.delete(`/ratings/${ratingId}`); // Example endpoint
};

/**
 * Fetches the rating given by a specific user for a specific cocktail.
 * @param userId - The ID of the user.
 * @param cocktailId - The ID of the cocktail.
 * @returns A promise that resolves to the user's rating for that cocktail, or null/error if not found.
 */
export const getUserRatingForCocktail = async (userId: number | string, cocktailId: number | string): Promise<Rating | null> => {
  // This endpoint might vary greatly, e.g., /users/{userId}/ratings/{cocktailId} or /ratings/?user_id=X&cocktail_id=Y
  try {
    const response = await apiClient.get<Rating>(`/users/${userId}/cocktails/${cocktailId}/rating`); // Adjust endpoint
    return response.data;
  } catch (error: any) {
    if (error.response && error.response.status === 404) {
      return null; // No rating found for this user and cocktail
    }
    throw error; // Re-throw other errors
  }
};
```

```ts
// frontend/src/services/tagService.ts
import apiClient from './apiClient';
import { Tag, TagCreate, TagUpdate, PaginatedResponse } from '@/types/cocktailTypes'; // Assuming Tag types are in cocktailTypes
import { CommonQueryPaginationParams } from '@/types/commonTypes';

export interface TagFilters extends CommonQueryPaginationParams {
  name?: string;
  // Add other filterable fields as needed
}

/**
 * Fetches a list of tags.
 * @param params - Optional filter and pagination parameters.
 * @returns A promise that resolves to an array of tags or a paginated response.
 */
export const getTags = async (params?: TagFilters): Promise<Tag[] | PaginatedResponse<Tag>> => {
  const response = await apiClient.get<Tag[] | PaginatedResponse<Tag>>('/tags/', { params });
  if ('items' in response.data && 'total' in response.data) {
    return response.data as PaginatedResponse<Tag>;
  }
  return response.data as Tag[];
};

/**
 * Fetches a single tag by its ID.
 * @param id - The ID of the tag.
 * @returns A promise that resolves to the tag details.
 */
export const getTagById = async (id: number | string): Promise<Tag> => {
  const response = await apiClient.get<Tag>(`/tags/${id}`);
  return response.data;
};

/**
 * Creates a new tag. (Primarily for admin users or if users can create tags)
 * @param data - The data for the new tag.
 * @returns A promise that resolves to the created tag.
 */
export const createTag = async (data: TagCreate): Promise<Tag> => {
  const response = await apiClient.post<Tag>('/tags/', data);
  return response.data;
};

/**
 * Updates an existing tag. (Primarily for admin users)
 * @param id - The ID of the tag to update.
 * @param data - The data to update the tag with.
 * @returns A promise that resolves to the updated tag.
 */
export const updateTag = async (id: number | string, data: TagUpdate): Promise<Tag> => {
  const response = await apiClient.put<Tag>(`/tags/${id}`, data);
  return response.data;
};

/**
 * Deletes a tag. (Primarily for admin users)
 * @param id - The ID of the tag to delete.
 * @returns A promise that resolves when the tag is deleted.
 */
export const deleteTag = async (id: number | string): Promise<void> => {
  await apiClient.delete(`/tags/${id}`);
};
```

```ts
// frontend/src/services/userService.ts
import apiClient from './apiClient';
import { User, UserUpdate, PaginatedResponse } from '@/types/authTypes'; // Assuming User type is in authTypes
import { CocktailWithDetails } from '@/types/cocktailTypes';
import { CommonQueryPaginationParams } from '@/types/commonTypes';

export interface UserFilters extends CommonQueryPaginationParams {
  username?: string;
  email?: string;
  // Add other filterable fields as needed
}

/**
 * Fetches a list of users. (Typically an admin-only action)
 * @param params - Optional filter and pagination parameters.
 * @returns A promise that resolves to an array of users or a paginated response.
 */
export const getUsers = async (params?: UserFilters): Promise<User[] | PaginatedResponse<User>> => {
  const response = await apiClient.get<User[] | PaginatedResponse<User>>('/users/', { params });
  if ('items' in response.data && 'total' in response.data) {
    return response.data as PaginatedResponse<User>;
  }
  return response.data as User[];
};

/**
 * Fetches a single user by their ID.
 * @param userId - The ID of the user.
 * @returns A promise that resolves to the user's data.
 */
export const getUserById = async (userId: number | string): Promise<User> => {
  const response = await apiClient.get<User>(`/users/${userId}`);
  return response.data;
};

/**
 * Updates a user's profile.
 * The current authenticated user can update their own profile using '/users/me'.
 * An admin might update any user via '/users/{userId}'.
 * @param userId - The ID of the user to update, or 'me' for the current user.
 * @param data - The data to update the user profile with.
 * @returns A promise that resolves to the updated user data.
 */
export const updateUser = async (userId: number | string, data: UserUpdate): Promise<User> => {
  const endpoint = userId === 'me' ? '/users/me' : `/users/${userId}`;
  const response = await apiClient.put<User>(endpoint, data);
  return response.data;
};

/**
 * Deletes a user. (Typically an admin-only action, or user deleting their own account)
 * @param userId - The ID of the user to delete.
 * @returns A promise that resolves when the user is deleted.
 */
export const deleteUser = async (userId: number | string): Promise<void> => {
  // Endpoint for deleting own account might be different, e.g., /users/me
  await apiClient.delete(`/users/${userId}`);
};

/**
 * Fetches cocktails created by a specific user.
 * @param userId - The ID of the user.
 * @param params - Optional pagination/filter parameters for the cocktails.
 * @returns A promise that resolves to an array or paginated response of cocktails.
 */
export const getUserCocktails = async (
    userId: number | string,
    params?: CommonQueryPaginationParams /* Add specific cocktail filters if needed */
  ): Promise<CocktailWithDetails[] | PaginatedResponse<CocktailWithDetails>> => {
    const response = await apiClient.get<CocktailWithDetails[] | PaginatedResponse<CocktailWithDetails>>(
      `/users/${userId}/cocktails`, 
      { params }
    );
    // Adapt based on whether your API always returns paginated or simple array
    if ('items' in response.data && 'total' in response.data) {
      return response.data as PaginatedResponse<CocktailWithDetails>;
    }
    return response.data as CocktailWithDetails[];
  };

// Other user-specific actions like:
// - Change password
// - Request password reset
// - Verify email
// should be added here as needed.
```

```css
// frontend/src/styles/global.css
/* More specific global styles, variables can be imported from variables.css */
@import './variables.css'; /* Import variables if you use them here */

/* Apply a natural box layout model to all elements */
*,
*::before,
*::after {
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: var(--font-family-base);
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  color: var(--color-text-primary);
  background-color: var(--color-background);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

main {
  flex-grow: 1; /* Ensures main content takes up available space, pushing footer down */
  padding: 1rem; /* General padding for main content area */
  /* max-width from App.css is fine, or define here */
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 0.75rem;
  font-weight: var(--font-weight-bold);
  line-height: 1.2;
  color: var(--color-headings);
}

h1 { font-size: 2.25rem; }
h2 { font-size: 1.75rem; }
h3 { font-size: 1.5rem; }
h4 { font-size: 1.25rem; }

p {
  margin-top: 0;
  margin-bottom: 1rem;
}

a {
  color: var(--color-primary);
  text-decoration: none;
  background-color: transparent;
}

a:hover {
  color: var(--color-primary-dark);
  text-decoration: underline;
}

img, svg {
  vertical-align: middle;
  max-width: 100%; /* Responsive images by default */
  height: auto;
}

/* Basic form styling (can be overridden by component-specific styles or CSS Modules) */
input[type="text"],
input[type="email"],
input[type="password"],
input[type="number"],
input[type="url"],
input[type="search"],
textarea,
select {
  display: block;
  width: 100%;
  padding: 0.5rem 0.75rem;
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5;
  color: var(--color-text-primary);
  background-color: #fff;
  background-clip: padding-box;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

input[type="text"]:focus,
input[type="email"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border-color: var(--color-primary-light);
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(var(--color-primary-rgb), 0.25); /* Convert hex to rgb for rgba */
}

/* Utility classes (optional) */
.text-center {
  text-align: center;
}

.mt-1 { margin-top: 0.25rem !important; }
.mb-1 { margin-bottom: 0.25rem !important; }
/* ... more margin/padding utilities as needed ... */

/* Accessibility */
.sr-only { /* Screen-reader only */
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
```

```css
// frontend/src/styles/variables.css
:root {
  /* Colors */
  --color-primary: #007bff;         /* Blue */
  --color-primary-light: #54a4ff;
  --color-primary-dark: #0056b3;
  --color-primary-rgb: 0, 123, 255;  /* For rgba() usage */

  --color-secondary: #6c757d;       /* Gray */
  --color-secondary-light: #a1a7ad;
  --color-secondary-dark: #545b62;

  --color-success: #28a745;         /* Green */
  --color-danger: #dc3545;          /* Red */
  --color-warning: #ffc107;         /* Yellow */
  --color-info: #17a2b8;            /* Teal */

  --color-light: #f8f9fa;           /* Very light gray / white */
  --color-dark: #343a40;            /* Dark gray / black */

  --color-background: #f4f4f9;      /* Light gray page background */
  --color-surface: #ffffff;         /* Card/modal backgrounds */
  
  --color-text-primary: #212529;    /* Main text color */
  --color-text-secondary: #6c757d;  /* Muted text, subtitles */
  --color-text-on-primary: #ffffff; /* Text on primary background */
  --color-text-on-dark: #ffffff;    /* Text on dark background */
  --color-headings: #333333;        /* Heading color */

  --color-border: #dee2e6;          /* Default border color */

  /* Typography */
  --font-family-sans-serif: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  --font-family-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --font-family-base: var(--font-family-sans-serif);

  --font-size-base: 1rem; /* Assumes 16px browser default */
  --font-size-sm: 0.875rem;
  --font-size-lg: 1.25rem;

  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-bold: 700;

  --line-height-base: 1.6;
  --line-height-sm: 1.25;
  --line-height-lg: 2;

  /* Spacing (can be used for margins, paddings) */
  --spacing-xs: 0.25rem; /* 4px */
  --spacing-sm: 0.5rem;  /* 8px */
  --spacing-md: 1rem;    /* 16px */
  --spacing-lg: 1.5rem;  /* 24px */
  --spacing-xl: 2rem;    /* 32px */
  --spacing-xxl: 3rem;   /* 48px */

  /* Borders */
  --border-width: 1px;
  --border-radius: 0.25rem; /* 4px */
  --border-radius-sm: 0.2rem;
  --border-radius-lg: 0.3rem;
  --border-radius-pill: 50rem;

  /* Box Shadows */
  --box-shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
  --box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
  --box-shadow-lg: 0 1rem 3rem rgba(0, 0, 0, 0.175);

  /* Navbar height (example, if needed globally) */
  --navbar-height: 60px;
}
```

```ts
// frontend/src/types/authTypes.ts
/**
 * Represents a user in the system.
 * This should match the Pydantic model returned by your FastAPI backend for user details,
 * excluding sensitive information like hashed_password.
 */
export interface User {
  id: number;
  email: string;
  username: string;
  is_active: boolean;
  is_superuser: boolean;
  profile_picture_url?: string | null; // Optional field
  // Add other fields like first_name, last_name, created_at, etc., as needed
}

/**
 * Credentials required for user login.
 */
export interface LoginCredentials {
  username: string; // Or email, depending on your backend setup
  password: string;
}

/**
 * Data required for new user registration.
 */
export interface RegisterData {
  email: string;
  password: string;
  username: string;
  // You might add other fields like first_name, last_name if they are part of registration
}

/**
 * Represents the structure of the token response from the backend's login endpoint.
 * Typically includes the access token and token type.
 */
export interface TokenResponse {
  access_token: string;
  token_type: string; // Usually "bearer"
  // Could also include refresh_token, expires_in, etc.
}

/**
 * Data for updating a user's profile.
 * All fields are optional as it's a partial update.
 */
export type UserUpdate = Partial<Omit<User, 'id' | 'is_active' | 'is_superuser' | 'email' >> & {
  // Email might be updatable but often requires a separate verification process.
  // Password updates should usually go through a dedicated "change password" endpoint.
  email?: string; 
  // current_password?: string; // Often required for sensitive changes like email or password
  // new_password?: string;
};

/**
 * If you use pagination for listing users (e.g., in an admin panel).
 */
export interface PaginatedUserResponse {
  items: User[];
  total: number;
  page: number;
  size: number;
  pages?: number; // Optional: total number of pages
}
```

```ts
// frontend/src/types/cocktailTypes.ts

/**
 * Represents an ingredient.
 */
export interface Ingredient {
  id: number;
  name: string;
  description?: string | null;
  // created_at?: string; // If you track creation/update times
  // updated_at?: string;
}

/**
 * Data for creating a new ingredient.
 */
export type IngredientCreate = Omit<Ingredient, 'id'>;

/**
 * Data for updating an existing ingredient (all fields optional).
 */
export type IngredientUpdate = Partial<IngredientCreate>;


/**
 * Represents a tag.
 */
export interface Tag {
  id: number;
  name: string;
  // created_at?: string;
  // updated_at?: string;
}

/**
 * Data for creating a new tag.
 */
export type TagCreate = Omit<Tag, 'id'>;

/**
 * Data for updating an existing tag.
 */
export type TagUpdate = Partial<TagCreate>;


/**
 * Enum for units of measurement for ingredients.
 * Should match the enum defined in your FastAPI backend.
 */
export enum UnitEnum {
  ml = "ml",
  l = "l", // Liter
  oz = "oz", // Ounce
  cl = "cl", // Centiliter
  piece = "piece",
  g = "g",   // Gram
  kg = "kg", // Kilogram
  dash = "dash",
  pinch = "pinch",
  splash = "splash", // Splash
  tsp = "tsp", // Teaspoon
  tbsp = "tbsp", // Tablespoon
  cup = "cup", // Cup
  slice = "slice",
  sprig = "sprig", // e.g. for mint
  leaf = "leaf", // e.g. for basil
  // Add other units as necessary
}

/**
 * Represents an ingredient used in a cocktail, including its quantity and unit.
 * This is for displaying cocktail details where ingredient info is populated.
 */
export interface CocktailIngredient {
  ingredient: Ingredient; // The full ingredient object
  quantity: number;
  unit: UnitEnum;
  // id?: number; // If this link has its own ID in a join table
}

/**
 * Base properties for a cocktail.
 */
export interface CocktailBase {
  name: string;
  description: string;
  instructions: string;
  image_url?: string | null;
  is_public: boolean; // Default to true or false based on your app logic
}

/**
 * Represents a cocktail with all its details, including populated ingredients and tags.
 * This is typically what you get when fetching a single cocktail or a list.
 */
export interface CocktailWithDetails extends CocktailBase {
  id: number;
  created_at: string;
  updated_at: string;
  average_rating: number | null; // Can be null if not rated
  total_ratings?: number; // Optional: number of ratings received
  ingredients: CocktailIngredient[];
  tags: Tag[];
  owner_id: number; // ID of the user who created the cocktail
  // owner?: User; // Optional: if you want to embed owner details
}

/**
 * Data structure for creating a new cocktail.
 * Ingredients and tags are referenced by their IDs.
 */
export interface CocktailCreate extends CocktailBase {
  ingredients: {
    ingredient_id: number;
    quantity: number;
    unit: UnitEnum;
  }[];
  tag_ids: number[]; // Array of tag IDs
}

/**
 * Data structure for updating an existing cocktail.
 * All fields are optional (Partial), and you might send only the changes.
 */
export type CocktailUpdate = Partial<CocktailCreate>;


/**
 * Represents a rating given to a cocktail.
 */
export interface Rating {
  id: number;
  score: number; // e.g., 1-5
  cocktail_id: number;
  user_id: number;
  created_at: string;
  updated_at: string;
  // comment?: string | null; // Optional: if ratings can have comments
}

/**
 * Data for creating a new rating.
 */
export type RatingCreate = Pick<Rating, 'score' | 'cocktail_id'>; // user_id usually from auth token

/**
 * Data for updating an existing rating (e.g., changing the score).
 */
export type RatingUpdate = Partial<Pick<Rating, 'score'>>;


/**
 * Generic paginated response structure from the API.
 */
export interface PaginatedResponse<T> {
  items: T[];
  total: number;    // Total number of items available
  page: number;     // Current page number
  size: number;     // Number of items per page
  pages?: number;   // Total number of pages (optional, can be calculated)
  next?: string | null; // URL for the next page
  previous?: string | null; // URL for the previous page
}
```

```ts
// frontend/src/types/commonTypes.ts

/**
 * Generic paginated response structure if not already defined in specific type files.
 * It's good practice to have a common one.
 */
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  size: number;
  pages?: number; // Optional, can be calculated: Math.ceil(total / size)
  // next_page?: number | null; // Alternative pagination info
  // prev_page?: number | null;
}

/**
 * Common query parameters for pagination.
 */
export interface CommonQueryPaginationParams {
  page?: number;  // Current page number (usually 1-indexed)
  size?: number; // Number of items per page
}

/**
 * Represents a generic error structure from the API, if consistent.
 * Often, FastAPI validation errors have a specific structure.
 */
export interface ApiErrorDetail {
  loc: (string | number)[]; // Location of the error (e.g., ["body", "field_name"])
  msg: string;             // Error message
  type: string;            // Error type (e.g., "value_error.missing")
}

export interface ApiErrorResponse {
  detail: string | ApiErrorDetail[]; // Can be a single message or an array of validation errors
}

/**
 * A simple key-value pair type for generic objects or dictionaries.
 */
export interface KeyValuePair<T = any> {
  [key: string]: T;
}
```

```ts
// frontend/src/types/index.ts
// This file re-exports types from other files in the types/ directory
// for easier importing into components and services.

export * from './authTypes';
export * from './cocktailTypes';
export * from './commonTypes';

// Example of a specific type that might combine others or be unique:
export interface AppNotification {
  id: string;
  type: 'success' | 'error' | 'info' | 'warning';
  message: string;
  duration?: number; // Optional: how long to display, in ms
}
```

```ts
// frontend/src/utils/helpers.ts

/**
 * Delays execution for a specified number of milliseconds.
 * Useful for simulating network latency or debouncing.
 * @param ms - The number of milliseconds to wait.
 * @returns A promise that resolves after the specified delay.
 */
export const delay = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * Capitalizes the first letter of a string.
 * @param str - The string to capitalize.
 * @returns The capitalized string, or an empty string if input is null/undefined.
 */
export const capitalizeFirstLetter = (str?: string | null): string => {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * Formats a date string or Date object into a more readable format.
 * Example: "January 1, 2023"
 * @param dateInput - The date string (ISO format) or Date object.
 * @param options - Optional Intl.DateTimeFormatOptions.
 * @returns Formatted date string, or an empty string if input is invalid.
 */
export const formatDate = (
  dateInput?: string | Date | null,
  options?: Intl.DateTimeFormatOptions
): string => {
  if (!dateInput) return '';
  try {
    const date = typeof dateInput === 'string' ? new Date(dateInput) : dateInput;
    const defaultOptions: Intl.DateTimeFormatOptions = {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      ...options,
    };
    return new Intl.DateTimeFormat('en-US', defaultOptions).format(date);
  } catch (error) {
    console.error('Error formatting date:', error);
    return ''; // Or return the original input, or a specific error string
  }
};

/**
 * Truncates a string to a specified length and appends an ellipsis if truncated.
 * @param text - The string to truncate.
 * @param maxLength - The maximum length of the string before truncation.
 * @param ellipsis - The string to append if truncated (default: "...").
 * @returns The truncated string or the original string if shorter than maxLength.
 */
export const truncateText = (text: string, maxLength: number, ellipsis: string = "..."): string => {
  if (text.length <= maxLength) {
    return text;
  }
  return text.substring(0, maxLength - ellipsis.length) + ellipsis;
};

/**
 * Generates a simple unique ID.
 * NOTE: For truly unique IDs in a distributed system, use libraries like `uuid`.
 * This is for simple client-side non-critical use.
 * @returns A string representing a unique ID.
 */
export const generateSimpleId = (): string => {
  return Math.random().toString(36).substring(2, 15);
};

/**
 * Parses JWT token to get payload data.
 * Does not verify the token signature.
 * @param token The JWT string.
 * @returns The payload object or null if parsing fails.
 */
export const parseJwtPayload = (token: string): Record<string, any> | null => {
  try {
    const base64Url = token.split('.')[1];
    if (!base64Url) return null;
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const jsonPayload = decodeURIComponent(
      atob(base64)
        .split('')
        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
        .join('')
    );
    return JSON.parse(jsonPayload);
  } catch (e) {
    console.error("Failed to parse JWT payload:", e);
    return null;
  }
};

// Add more helper functions as your application grows.
```

```ts
// frontend/src/utils/localStorage.ts

/**
 * Safely retrieves an item from localStorage and parses it as JSON.
 * @param key - The key of the item to retrieve.
 * @returns The parsed item, or null if the item doesn't exist or parsing fails.
 *          Type T is the expected type of the stored item.
 */
export const getItem = <T>(key: string): T | null => {
  try {
    const item = window.localStorage.getItem(key);
    return item ? (JSON.parse(item) as T) : null;
  } catch (error) {
    console.error(`Error getting item "${key}" from localStorage:`, error);
    return null;
  }
};

/**
 * Safely stores an item in localStorage after serializing it to JSON.
 * @param key - The key under which to store the item.
 * @param value - The value to store. It will be JSON.stringified.
 *                Type T is the type of the value being stored.
 */
export const setItem = <T>(key: string, value: T): void => {
  try {
    const serializedValue = JSON.stringify(value);
    window.localStorage.setItem(key, serializedValue);
  } catch (error) {
    console.error(`Error setting item "${key}" in localStorage:`, error);
  }
};

/**
 * Safely removes an item from localStorage.
 * @param key - The key of the item to remove.
 */
export const removeItem = (key: string): void => {
  try {
    window.localStorage.removeItem(key);
  } catch (error) {
    console.error(`Error removing item "${key}" from localStorage:`, error);
  }
};

/**
 * Clears all items from localStorage.
 * Use with caution, as this will remove all data stored by your application.
 */
export const clearAll = (): void => {
  try {
    window.localStorage.clear();
  } catch (error) {
    console.error('Error clearing localStorage:', error);
  }
};

// Example of a more specific localStorage utility for a common item:
// const AUTH_TOKEN_KEY = 'authToken';

// export const getAuthToken = (): string | null => {
//   return getItem<string>(AUTH_TOKEN_KEY);
// };

// export const setAuthToken = (token: string): void => {
//   setItem<string>(AUTH_TOKEN_KEY, token);
// };

// export const removeAuthToken = (): void => {
//   removeItem(AUTH_TOKEN_KEY);
// };
```

```typescript
// frontend/src/vite-env.d.ts
/// <reference types="vite/client" />

// To make TypeScript aware of environment variables prefixed with VITE_
interface ImportMetaEnv {
  readonly VITE_API_BASE_URL: string;
  // Add other environment variables here if needed
  // readonly VITE_ANOTHER_VAR: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

```json
// frontend/tsconfig.app.json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "jsx": "react-jsx"
  },
  "include": ["src"]
}
```

```json
// frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true, // Vite handles emission, tsc is for type checking
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,

    /* Aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src", "vite.config.ts", "eslint.config.js", "postcss.config.js"], // Add other config files if needed
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

```json
// frontend/tsconfig.node.json
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "noEmit": true // Do not emit JS from this config, it's for type checking Node.js context files
  },
  "include": ["vite.config.ts", "eslint.config.js", "postcss.config.js"] // Add other config files if needed
}
```

```ts
// frontend/vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react-swc';
import path from 'path'; // Import path module for resolving aliases

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'), // Setup '@' alias to point to 'src' directory
    },
  },
  server: {
    port: 3000, // Optional: specify dev server port
    open: true,   // Optional: open browser on server start
  },
  build: {
    outDir: 'dist', // Output directory for production build
    // sourcemap: true, // Optional: generate sourcemaps for production
  },
});
```

```json
// frontend/.prettierrc.json
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 80,
  "tabWidth": 2,
  "jsxSingleQuote": false,
  "arrowParens": "always"
}
```
To wszystko! Ta struktura i kod boilerplate powinny stanowić solidną podstawę dla Twojej aplikacji "KoktajLOVE". Pamiętaj o zainstalowaniu zależności (`npm install`) i dostosowaniu endpointów API oraz logiki do specyfikacji Twojego backendu.